var documenterSearchIndex = {"docs":
[{"location":"man/material_physics/#Material-physics","page":"Material physics","title":"Material physics","text":"","category":"section"},{"location":"man/material_physics/","page":"Material physics","title":"Material physics","text":"JustRelax is fully integrated with GeoParams.jl to perform all the material physics computations.","category":"page"},{"location":"man/ShearBands/#ShearBand-benchmark","page":"Shear Bands","title":"ShearBand benchmark","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Band benchmark to test the visco-elasto-plastic rheology implementation in JustRelax.jl","category":"page"},{"location":"man/ShearBands/#Initialize-packages","page":"Shear Bands","title":"Initialize packages","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Load JustRelax necessary modules and define backend.","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GeoParams","category":"page"},{"location":"man/ShearBands/#Script","page":"Shear Bands","title":"Script","text":"","category":"section"},{"location":"man/ShearBands/#Model-domain","page":"Shear Bands","title":"Model domain","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"nx = ny      = 64                       # number of cells per dimension\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly                       # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt           = Inf","category":"page"},{"location":"man/ShearBands/#Physical-properties-using-GeoParams","page":"Shear Bands","title":"Physical properties using GeoParams","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"τ_y     = 1.6           # yield stress. If do_DP=true, τ_y stand for the cohesion: c*cos(ϕ)\nϕ       = 30            # friction angle\nC       = τ_y           # Cohesion\nη0      = 1.0           # viscosity\nG0      = 1.0           # elastic shear modulus\nGi      = G0/(6.0-4.0)  # elastic shear modulus perturbation\nεbg     = 1.0           # background strain-rate\nη_reg   = 8e-3          # regularisation \"viscosity\"\ndt      = η0/G0/4.0     # assumes Maxwell time of 4\nel_bg   = ConstantElasticity(; G=G0, Kb=4)\nel_inc  = ConstantElasticity(; G=Gi, Kb=4)\nvisc    = LinearViscous(; η=η0)\npl      = DruckerPrager_regularised(;  # non-regularized plasticity\n    C    = C,\n    ϕ    = ϕ,\n    η_vp = η_reg,\n    Ψ    = 0\n)","category":"page"},{"location":"man/ShearBands/#Rheology","page":"Shear Bands","title":"Rheology","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    rheology = (\n        # Low density phase\n        SetMaterialParams(;\n            Phase             = 1,\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_bg, pl)),\n            Elasticity        = el_bg,\n\n        ),\n        # High density phase\n        SetMaterialParams(;\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_inc, pl)),\n            Elasticity        = el_inc,\n        ),\n    )","category":"page"},{"location":"man/ShearBands/#Phase-anomaly","page":"Shear Bands","title":"Phase anomaly","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"function init_phases!(phase_ratios, xci, radius)\n    ni      = size(phase_ratios.center)\n    origin  = 0.5, 0.5\n\n    @parallel_indices (i, j) function init_phases!(phases, xc, yc, o_x, o_y, radius)\n        x, y = xc[i], yc[j]\n        if ((x-o_x)^2 + (y-o_y)^2) > radius^2\n            JustRelax.@cell phases[1, i, j] = 1.0\n            JustRelax.@cell phases[2, i, j] = 0.0\n\n        else\n            JustRelax.@cell phases[1, i, j] = 0.0\n            JustRelax.@cell phases[2, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phase_ratios.center, xci..., origin..., radius)\nend\n","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\ninit_phases!(phase_ratios, xci, radius)","category":"page"},{"location":"man/ShearBands/#Stokes-arrays","page":"Shear Bands","title":"Stokes arrays","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Stokes arrays object","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/ShearBands/#Initialize-viscosity-fields","page":"Shear Bands","title":"Initialize viscosity fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/ShearBands/#Boundary-conditions","page":"Shear Bands","title":"Boundary conditions","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    flow_bcs     = FlowBoundaryConditions(;\n        free_slip = (left = true, right = true, top = true, bot = true),\n        no_slip   = (left = false, right = false, top = false, bot=false),\n    )\n    stokes.V.Vx .= PTArray([ x*εbg for x in xvi[1], _ in 1:ny+2])\n    stokes.V.Vy .= PTArray([-y*εbg for _ in 1:nx+2, y in xvi[2]])\n    flow_bcs!(stokes, flow_bcs) # apply boundary conditions\n    update_halo!(stokes.V.Vx, stokes.V.Vy)\n","category":"page"},{"location":"man/ShearBands/#Pseuo-transient-coefficients","page":"Shear Bands","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)","category":"page"},{"location":"man/ShearBands/#Just-before-solving-the-problem...","page":"Shear Bands","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"In this benchmark we want to keep track of τII, the total time ttot, and the analytical elastic solution sol","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" solution(ε, t, G, η) = 2 * ε * η * (1 - exp(-G * t / η))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and store their time history in the vectors:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    τII        = Float64[]\n    sol        = Float64[]\n    ttot       = Float64[]","category":"page"},{"location":"man/ShearBands/#Advancing-one-time-step","page":"Shear Bands","title":"Advancing one time step","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Solve stokes","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    dt,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"calculate the second invariant and push to history vectors","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"tensor_invariant!(stokes.ε)\npush!(τII, maximum(stokes.τ.xx))\n\n@parallel (@idx ni .+ 1) multi_copy!(@tensor(stokes.τ_o), @tensor(stokes.τ))\n@parallel (@idx ni) multi_copy!(\n    @tensor_center(stokes.τ_o), @tensor_center(stokes.τ)\n)\n\nit += 1\nt  += dt\n\npush!(sol, solution(εbg, t, G0, η0))\npush!(ttot, t)","category":"page"},{"location":"man/ShearBands/#Visualization","page":"Shear Bands","title":"Visualization","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GLMakie","category":"page"},{"location":"man/ShearBands/#Fields","page":"Shear Bands","title":"Fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" # visualisation of high density inclusion\nth    = 0:pi/50:3*pi;\nxunit = @. radius * cos(th) + 0.5;\nyunit = @. radius * sin(th) + 0.5;\n\nfig   = Figure(size = (1600, 1600), title = \"t = $t\")\nax1   = Axis(fig[1,1], aspect = 1, title = L\"\\tau_{II}\", titlesize=35)\nax2   = Axis(fig[2,1], aspect = 1, title = L\"E_{II}\", titlesize=35)\nax3   = Axis(fig[1,2], aspect = 1, title = L\"\\log_{10}(\\varepsilon_{II})\", titlesize=35)\nax4   = Axis(fig[2,2], aspect = 1)\nheatmap!(ax1, xci..., Array(stokes.τ.II) , colormap=:batlow)\nheatmap!(ax2, xci..., Array(log10.(stokes.EII_pl)) , colormap=:batlow)\nheatmap!(ax3, xci..., Array(log10.(stokes.ε.II)) , colormap=:batlow)\nlines!(ax2, xunit, yunit, color = :black, linewidth = 5)\nlines!(ax4, ttot, τII, color = :black)\nlines!(ax4, ttot, sol, color = :red)\nhidexdecorations!(ax1)\nhidexdecorations!(ax3)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/ShearBands/#Final-model","page":"Shear Bands","title":"Final model","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Bands evolution in a 2D visco-elasto-plastic rheology model (Image: Shearbands)","category":"page"},{"location":"man/Blankenbach/#Blankenbach-benchmark","page":"Blankenbach","title":"Blankenbach benchmark","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Thermal convection benchmark from  Blankenbach et al., 1989","category":"page"},{"location":"man/Blankenbach/#Initialize-packages","page":"Blankenbach","title":"Initialize packages","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Load JustRelax necessary modules and define backend.","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"For this benchmark we will use particles to track the advection of the material phases and their information. For this, we will use JustPIC.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustPIC, JustPIC._2D\nconst backend = CPUBackend # Options: CPUBackend, CUDABackend, AMDGPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GeoParams","category":"page"},{"location":"man/Blankenbach/#Script","page":"Blankenbach","title":"Script","text":"","category":"section"},{"location":"man/Blankenbach/#Model-domain","page":"Blankenbach","title":"Model domain","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nx = ny      = 51                       # number of cells per dimension\nnit          = 6e3\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly * ar                  # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt = dt_diff = 0.9 * min(di...)^2 / 4.0 # diffusive CFL timestep limiter","category":"page"},{"location":"man/Blankenbach/#Rheology","page":"Blankenbach","title":"Rheology","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"rheology = (\n    SetMaterialParams(;\n        Phase             = 1,\n        Density           = PT_Density(; ρ0 = 1, α = 1, β = 0.0),\n        HeatCapacity      = ConstantHeatCapacity(; Cp = 1.0),\n        Conductivity      = ConstantConductivity(;  k = 1.0),\n        CompositeRheology = CompositeRheology((LinearViscous(; η = 1),)),\n        RadioactiveHeat   = ConstantRadioactiveHeat(0.0),\n        Gravity           = ConstantGravity(; g = 1e4),\n    ),\n)","category":"page"},{"location":"man/Blankenbach/#Initialize-particles","page":"Blankenbach","title":"Initialize particles","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nxcell              = 24 # initial number of perticles per cell\nmax_xcell           = 35 # maximum number of perticles per cell\nmin_xcell           = 12 # minimum number of perticles per cell\nparticles           = init_particles(\n    backend, nxcell, max_xcell, min_xcell, xvi..., di..., ni...\n) # particles object\nsubgrid_arrays      = SubgridDiffusionCellArrays(particles) # arrays needed for subgrid diffusion\n# velocity grids\ngrid_vx, grid_vy    = velocity_grids(xci, xvi, di) # staggered velocity grids","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we want to keep track of the temperature pT, temperature of the previous time step pT0, and material phase pPhase:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pT, pT0, pPhases = init_cell_arrays(particles, Val(3))\nparticle_args    = (pT, pT0, pPhases)","category":"page"},{"location":"man/Blankenbach/#Temperature-anomaly","page":"Blankenbach","title":"Temperature anomaly","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"xc_anomaly = 0.0     # origin of thermal anomaly\nyc_anomaly = 1 / 3   # origin of thermal anomaly\nr_anomaly  = 0.1 / 2 # radius of perturbation","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function init_phases!(phases, particles)\n    ni = size(phases)\n\n    @parallel_indices (i, j) function init_phases!(phases, index)\n        @inbounds for ip in JustRelax.cellaxes(phases)\n            # quick escape if the ip-th element of the [i,j]-th cell is empty\n            JustRelax.@cell(index[ip, i, j]) == 0 && continue\n            # all particles have phase number = 1.0\n            JustRelax.@cell phases[ip, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phases, particles.index)\nend\n\ninit_phases!(pPhases, particles, lx, yc_anomaly, r_anomaly)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or we can use the alternative one-liners","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@views pPhase.data[!isnan.(particles.index.data)] .= 1.0","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"map!(x -> isnan(x) ? NaN : 1.0, pPhase.data, particles.index.data)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/#Stokes-and-heat-diffusion-arrays","page":"Blankenbach","title":"Stokes and heat diffusion arrays","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Stokes arrays object","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the correspondent heat diffusion one","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"thermal = ThermalArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/#Initialize-thermal-profile-and-viscosity-fields","page":"Blankenbach","title":"Initialize thermal profile and viscosity fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"To initialize the thermal profile we use ParallelStencil.jl again","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@parallel_indices (i, j) function init_T!(T, y)\n    T[i, j] = 1 - y[j]\n    return nothing\nend\n\n@parallel (@idx size(thermal.T))  init_T!(thermal.T,  xvi[2]) # cell vertices\n@parallel (@idx size(thermal.Tc)) init_T!(thermal.Tc, xci[2]) # cell centers","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we define a rectangular thermal anomaly at x in 0 005, y in frac13 - 005 frac13 + 005","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function rectangular_perturbation!(T, xc, yc, r, xvi)\n    @parallel_indices (i, j) function _rectangular_perturbation!(T, xc, yc, r, x, y)\n        @inbounds if ((x[i]-xc)^2 ≤ r^2) && ((y[j] - yc)^2 ≤ r^2)\n            T[i, j] += .2\n        end\n        return nothing\n    end\n    ni = size(T)\n    @parallel (@idx ni) _rectangular_perturbation!(T, xc, yc, r, xvi...)\n    return nothing\nend\n\nxc_anomaly  = 0.0    # center of the thermal anomaly\nyc_anomaly  = 1/3    # center of the thermal anomaly\nr_anomaly   = 0.1/2  # half-width of the thermal anomaly\nrectangular_perturbation!(thermal.T, xc_anomaly, yc_anomaly, r_anomaly, xvi)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/Blankenbach/#Boundary-conditions","page":"Blankenbach","title":"Boundary conditions","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"flow_bcs      = FlowBoundaryConditions(;\n    free_slip = (left = true, right=true, top=true, bot=true),\n)\nthermal_bc    = TemperatureBoundaryConditions(;\n    no_flux   = (left = true, right = true, top = false, bot = false),\n)\nthermal_bcs!(thermal.T, thermal_bc)\nthermal.Told .= thermal.T","category":"page"},{"location":"man/Blankenbach/#Pseuo-transient-coefficients","page":"Blankenbach","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)\npt_thermal  = PTThermalCoeffs(\n    backend_JR, rheology, phase_ratios, args, dt, ni, di, li; ϵ=1e-5, CFL = 1e-1 / √2.1\n)","category":"page"},{"location":"man/Blankenbach/#Just-before-solving-the-problem...","page":"Blankenbach","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We need to allocate some arrays to be able to do the subgrid diffusion of the temperature field at the particles level:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"T_buffer    = @zeros(ni.+1)     # without the ghost nodes at the x-direction\nTold_buffer = similar(T_buffer) # without the ghost nodes at the x-direction\ndt₀         = similar(stokes.P) # subgrid diffusion time scale\n# copy temperature to buffer arrays\nfor (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\n# interpolate temperatyre on the particles\ngrid2particle!(pT, xvi, T_buffer, particles)\npT0.data    .= pT.data","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function copyinn_x!(A, B)\n    @parallel function f_x(A, B)\n        @all(A) = @inn_x(B)\n        return nothing\n    end\n    @parallel f_x(A, B)\nend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"In this benchmark we want to keep track of the time trms, the rms-velocity Urms","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"$","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"U{rms} = \\sqrt{ \\int{\\Omega} (Vx^2 + Vy^2 ) d\\Omega} $","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the Nusselt number at the top of the model Nu_top","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"$","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Nu_{top} = \\int \\frac{\\partial T}{\\partial x} dx $","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And we will store their time history in the vectors:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Urms   = Float64[]\nNu_top = Float64[]\ntrms   = Float64[]","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We further need two buffer arrays where to interpolate the velocity field at the vertices of the grid cells","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Buffer arrays to compute velocity rms\nVx_v = @zeros(ni.+1...)\nVy_v = @zeros(ni.+1...)","category":"page"},{"location":"man/Blankenbach/#Advancing-one-time-step","page":"Blankenbach","title":"Advancing one time step","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Solve stokes","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    Inf,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)\n# calculate adaptive time step\ndt = compute_dt(stokes, di, dt_diff)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Heat diffusion solver","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"heatdiffusion_PT!(\n    thermal,\n    pt_thermal,\n    thermal_bc,\n    rheology,\n    args,\n    dt,\n    di;\n    kwargs = (;\n        igg     = igg,\n        phase   = phase_ratios,\n        iterMax = 10e3,\n        nout    = 1e2,\n        verbose = true,\n    )\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Subgrid diffusion at the particle level","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"for (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\nsubgrid_characteristic_time!(\n    subgrid_arrays, particles, dt₀, phase_ratios, rheology, thermal, stokes, xci, di\n)\ncentroid2particle!(subgrid_arrays.dt₀, xci, dt₀, particles)\nsubgrid_diffusion!(\n    pT, T_buffer, thermal.ΔT[2:end-1, :], subgrid_arrays, particles, xvi,  di, dt\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Advect particles","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# advect particles in space\nadvection!(particles, RungeKutta2(), @velocity(stokes), (grid_vx, grid_vy), dt)\n# advect particles in memory\nmove_particles!(particles, xvi, particle_args)\n# check if we need to inject particles\ninject_particles_phase!(particles, pPhases, (pT, ), (T_buffer, ), xvi)\n# update phase ratios\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Interpolate T back to the grid","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# interpolate fields from particle to grid vertices\nparticle2grid!(T_buffer, pT, xvi, particles)\n@views T_buffer[:, end]      .= 0.0\n@views T_buffer[:, 1]        .= 1.0\n@views thermal.T[2:end-1, :] .= T_buffer\nflow_bcs!(stokes, flow_bcs) # apply boundary conditions\ntemperature2center!(thermal)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Update buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"args = (; T = thermal.Tc, P = stokes.P,  dt=Inf)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Compute Nusselt number and rms-velocity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Nusselt number, Nu = ∫ ∂T/∂z dx\nNu_it = sum( ((abs.(thermal.T[2:end-1,end] - thermal.T[2:end-1,end-1])) ./ di[2]) .*di[1])\npush!(Nu_top, Nu_it)\n# Compute U rms\n# U₍ᵣₘₛ₎ = √ ∫∫ (vx²+vz²) dx dz\nUrms_it = let\n    JustRelax.JustRelax2D.velocity2vertex!(Vx_v, Vy_v, stokes.V.Vx, stokes.V.Vy; ghost_nodes=true)\n    @. Vx_v .= hypot.(Vx_v, Vy_v) # we reuse Vx_v to store the velocity magnitude\n    sqrt(sum( Vx_v.^2 .* prod(di)) )\nend\npush!(Urms, Urms_it)\npush!(trms, t)","category":"page"},{"location":"man/Blankenbach/#Visualization","page":"Blankenbach","title":"Visualization","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GLMakie","category":"page"},{"location":"man/Blankenbach/#Fields","page":"Blankenbach","title":"Fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Make particles plottable\np        = particles.coords\nppx, ppy = p\npxv      = ppx.data[:]\npyv      = ppy.data[:]\nclr      = pT.data[:]\nidxv     = particles.index.data[:];\n\n# Make Makie figure\nfig = Figure(size = (900, 900), title = \"t = $t\")\nax1 = Axis(fig[1,1], aspect = ar, title = \"T [K]  (t=$(t/(1e6 * 3600 * 24 *365.25)) Myrs)\")\nax2 = Axis(fig[2,1], aspect = ar, title = \"Vy [m/s]\")\nax3 = Axis(fig[1,3], aspect = ar, title = \"Vx [m/s]\")\nax4 = Axis(fig[2,3], aspect = ar, title = \"T [K]\")\n# grid temperature\nh1  = heatmap!(ax1, xvi[1], xvi[2], Array(thermal.T[2:end-1,:]) , colormap=:lajolla, colorrange=(0, 1) )\n# y-velocity\nh2  = heatmap!(ax2, xvi[1], xvi[2], Array(stokes.V.Vy) , colormap=:batlow)\n# x-velocity\nh3  = heatmap!(ax3, xvi[1], xvi[2], Array(stokes.V.Vx) , colormap=:batlow)\n# particles temperature\nh4  = scatter!(ax4, Array(pxv[idxv]), Array(pyv[idxv]), color=Array(clr[idxv]), colormap=:lajolla, colorrange=(0, 1), markersize=3)\nhidexdecorations!(ax1)\nhidexdecorations!(ax2)\nhidexdecorations!(ax3)\nColorbar(fig[1,2], h1)\nColorbar(fig[2,2], h2)\nColorbar(fig[1,4], h3)\nColorbar(fig[2,4], h4)\nlinkaxes!(ax1, ax2, ax3, ax4)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/Blankenbach/#Final-model","page":"Blankenbach","title":"Final model","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Temperature field (Image: Temperatuere)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And time history of the rms-velocity and Nusselt number (Image: time series)","category":"page"},{"location":"man/advection/#Field-advection","page":"Advection","title":"Field advection","text":"","category":"section"},{"location":"man/advection/#Particles-in-Cell","page":"Advection","title":"Particles-in-Cell","text":"","category":"section"},{"location":"man/advection/","page":"Advection","title":"Advection","text":"JustRelax relies on JustPIC.jl for advections of particles containing material information.","category":"page"},{"location":"man/advection/#Upwind","page":"Advection","title":"Upwind","text":"","category":"section"},{"location":"man/advection/#WENO5","page":"Advection","title":"WENO5","text":"","category":"section"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here an overview of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [JustRelax]","category":"page"},{"location":"man/listfunctions/#JustRelax.Geometry","page":"List of functions","title":"JustRelax.Geometry","text":"struct Geometry{nDim,T}\n\nA struct representing the geometry of a topological object in nDim dimensions.\n\nArguments\n\nnDim: The number of dimensions of the topological object.\nT: The type of the elements in the topological object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.cart2ind-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{Int64, N1}}, Vararg{Int64, N2}}} where {N1, N2}","page":"List of functions","title":"JustRelax.cart2ind","text":"cart2ind(A)\n\nReturn the linear index of a n-dimensional array corresponding to the cartesian indices I\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.element-Union{Tuple{D}, Tuple{Nc}, Tuple{N}, Tuple{T_elem}, Tuple{CellArrays.CellArray{StaticArraysCore.SVector, N, D, T_elem}, Int64, Vararg{Int64, Nc}}} where {T_elem, N, Nc, D}","page":"List of functions","title":"JustRelax.element","text":"element(A, element_indices..., cell_indices...)\n\nReturn a the element with element_indices of the Cell with cell_indices of the CellArray A.\n\nArguments\n\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.setelement!-Union{Tuple{D}, Tuple{T_elem}, Tuple{N}, Tuple{T}, Tuple{N_array}, Tuple{Nj}, Tuple{Ni}, Tuple{Nc}, Tuple{CellArrays.CellArray{StaticArraysCore.SMatrix{Ni, Nj, T, N_array}, N, D, T_elem}, T, Any, Any, Vararg{Int64, Nc}}} where {Nc, Ni, Nj, N_array, T, N, T_elem, D}","page":"List of functions","title":"JustRelax.setelement!","text":"setelement!(A, x, element_indices..., cell_indices...)\n\nStore the given value x at the given element with element_indices of the cell with the indices cell_indices\n\nArguments\n\nx::Number: value to be stored in the index element_indices of the cell with cell_indices.\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.velocity_grids-Union{Tuple{T}, Tuple{Any, Any, Tuple{T, T}}} where T","page":"List of functions","title":"JustRelax.velocity_grids","text":"velocity_grids(xci, xvi, di::NTuple{N,T}) where {N,T}\n\nCompute the velocity grids for N dimensionional problems.\n\nArguments\n\nxci: The x-coordinate of the cell centers.\nxvi: The x-coordinate of the cell vertices.\ndi: A tuple containing the cell dimensions.\n\n\n\n\n\n","category":"method"},{"location":"man/backend/#Selecting-the-backend","page":"Backend","title":"Selecting the backend","text":"","category":"section"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"JustRelax supports three backends: CPU, and CUDA and AMD GPU cards. To use the default CPU backend, simply load JustRelax:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"The GPU backends are implemented as extensions, so it is enough to load the appropriate GPU Pkg before loading JustRelax. That is, to use CUDA cards:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using CUDA, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and for AMD cards:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using AMDGPU, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"Two and three dimensional solvers are implemented in different submodules, which also need to be loaded. To use the two-dimensional backend:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax2D","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and for the three-dimensional backend:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax3D","category":"page"},{"location":"man/#JustRelax.jl","page":"Home","title":"JustRelax.jl","text":"","category":"section"},{"location":"man/","page":"Home","title":"Home","text":"Need to solve a very large multi-physics problem on many GPUs in parallel? Just Relax!","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"JustRelax is a collection of accelerated iterative pseudo-transient solvers using MPI and multiple CPU or GPU backends. It's part of the PTSolvers organisation and developed within the GPU4GEO project. Current publications, outreach and news can be found on the GPU4GEO website.","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"The package relies on other packages as building blocks and parallelisation tools:","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"ParallelStencil.jl - device agnostic parallel kernels\nImplicitGlobalGrid.jl - (CUDA-aware) MPI communication\nGeoParams.jl - Material physics\nJustPIC.jl - Particle-in-cell advection","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"The package serves several purposes:","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"It provides a collection of solvers to be used in quickly developing new applications\nIt provides some standardization so that application codes can\nmore easily handle local material properties through the use of GeoParams.jl\nmore easily switch between a pseudo-transient solver and another solvers (e.g. an explicit thermal solvers)\nIt provides a natural repository for contributions of new solvers for use by the larger community","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"We provide several miniapps, each designed to solve a well-specified benchmark problem, in order to provide","category":"page"},{"location":"man/","page":"Home","title":"Home","text":"examples of usage in high-performance computing\nbasis on which to build more full-featured application codes\ncases for reference and performance tests","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"JustRelax is a registered package and can be added as follows:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.add(\"JustRelax\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.10) pkg> add JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"However, as the API is changing and not every feature leads to a new release, one can also do add JustRelax#main which will clone the main branch of the repository. After installation, you can test the package by running the following commands:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using JustRelax\njulia> ]\n  pkg> test JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The test will take a while, so grab a :coffee: or :tea:","category":"page"},{"location":"man/equations/#Pseudo-transient-iterative-method","page":"Equations","title":"Pseudo-transient iterative method","text":"","category":"section"},{"location":"man/equations/#Heat-diffusion","page":"Equations","title":"Heat diffusion","text":"","category":"section"},{"location":"man/equations/#Stokes-equations","page":"Equations","title":"Stokes equations","text":"","category":"section"},{"location":"man/equations/#Constitutive-equations","page":"Equations","title":"Constitutive equations","text":"","category":"section"}]
}
