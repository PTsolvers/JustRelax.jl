var documenterSearchIndex = {"docs":
[{"location":"man/security/#Security-Policy","page":"Security","title":"Security Policy","text":"","category":"section"},{"location":"man/security/","page":"Security","title":"Security","text":"We take security issues seriously. We appreciate all efforts to responsibly disclose any security issues and will make every effort to acknowledge contributions.","category":"page"},{"location":"man/security/#Supported-Versions","page":"Security","title":"Supported Versions","text":"","category":"section"},{"location":"man/security/","page":"Security","title":"Security","text":"The current stable release following the interpretation of semantic versioning (SemVer) used in the Julia ecosystem is supported with security updates.","category":"page"},{"location":"man/security/#Reporting-a-Vulnerability","page":"Security","title":"Reporting a Vulnerability","text":"","category":"section"},{"location":"man/security/","page":"Security","title":"Security","text":"To report a security issue, please use the GitHub Security Advisory \"Report a Vulnerability\" tab.","category":"page"},{"location":"man/security/","page":"Security","title":"Security","text":"We will send a response indicating the next steps in handling your report. After the initial reply to your report, we will keep you informed of the progress towards a fix and full announcement, and may ask for additional information or guidance.","category":"page"},{"location":"man/security/","page":"Security","title":"Security","text":"Please report security bugs in third-party modules directly to the person or team maintaining the module.","category":"page"},{"location":"man/security/","page":"Security","title":"Security","text":"Public notifications of vulnerabilities will be shared in community channels such as Slack.","category":"page"},{"location":"man/boundary_conditions/#Flow-boundary-conditions","page":"Boundary conditions","title":"Flow boundary conditions","text":"","category":"section"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Supported boundary conditions:","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Free slip\nfracpartial u_ipartial x_i = 0 at the boundary Gamma\nNo slip\nu_i = 0 at the boundary Gamma\nFree surface\nsigma_z = 0 rightarrow tau_z = P at the top boundary","category":"page"},{"location":"man/boundary_conditions/#Defining-the-boundary-conditions","page":"Boundary conditions","title":"Defining the boundary conditions","text":"","category":"section"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"We have two ways of defining the boundary condition formulations:     - VelocityBoundaryConditions, and     - DisplacementBoundaryConditions. The first one is used for the velocity-pressure formulation, and the second one is used for the displacement-pressure formulation. The flow boundary conditions can be switched on and off by setting them as true or false at the appropriate boundaries. Valid boundary names are left and right, top and bot, and for the 3D case, front and back.","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"For example, if we want to have free free-slip in every single boundary in a 2D simulation, we need to instantiate VelocityBoundaryConditions or DisplacementBoundaryConditions as:","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"bcs = VelocityBoundaryConditions(;\n    no_slip      = (left=false, right=false, top=false, bot=false),\n    free_slip    = (left=true, right=true, top=true, bot=true),\n    free_surface = false\n)\nbcs = DisplacementBoundaryConditions(;\n    no_slip      = (left=false, right=false, top=false, bot=false),\n    free_slip    = (left=true, right=true, top=true, bot=true),\n    free_surface = false\n)","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The equivalent for the 3D case would be:","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"bcs = VelocityBoundaryConditions(;\n    no_slip      = (left=false, right=false, top=false, bot=false, front=false, back=false),\n    free_slip    = (left=true, right=true, top=true, bot=true, front=true, back=true),\n    free_surface = false\n)\nbcs = DisplacementBoundaryConditions(;\n    no_slip      = (left=false, right=false, top=false, bot=false, front=false, back=false),\n    free_slip    = (left=true, right=true, top=true, bot=true, front=true, back=true),\n    free_surface = false\n)","category":"page"},{"location":"man/boundary_conditions/#Prescribing-the-velocity/displacement-boundary-conditions","page":"Boundary conditions","title":"Prescribing the velocity/displacement boundary conditions","text":"","category":"section"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Normally, one would prescribe the velocity/displacement boundary conditions by setting the velocity/displacement field at the boundary through the application of a background strain rate εbg. Depending on the formulation, the velocity/displacement field is set as follows for the 2D case:","category":"page"},{"location":"man/boundary_conditions/#Velocity-formulation","page":"Boundary conditions","title":"Velocity formulation","text":"","category":"section"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"stokes.V.Vx .= PTArray(backend)([ x*εbg for x in xvi[1], _ in 1:ny+2]) # Velocity in x direction\nstokes.V.Vy .= PTArray(backend)([-y*εbg for _ in 1:nx+2, y in xvi[2]]) # Velocity in y direction","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Make sure to apply the set velocity to the boundary conditions. You do this by calling the flow_bcs! function,","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"flow_bcs!(stokes, flow_bcs)","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"and then applying the velocities to the halo","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"update_halo!(@velocity(stokes)...)","category":"page"},{"location":"man/boundary_conditions/#Displacement-formulation","page":"Boundary conditions","title":"Displacement formulation","text":"","category":"section"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"stokes.U.Ux .= PTArray(backend)([ x*εbg*lx*dt for x in xvi[1], _ in 1:ny+2]) # Displacement in x direction\nstokes.U.Uy .= PTArray(backend)([-y*εbg*ly*dt for _ in 1:nx+2, y in xvi[2]]) # Displacement in y direction\nflow_bcs!(stokes, flow_bcs)","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Make sure to initialize the displacement according to the extent of your domain. Here, lx and ly are the domain lengths in the x and y directions, respectively. Also for the displacement formulation it is important that the displacement is converted to velocity before updating the halo. This can be done by calling the displacement2velocity! function.","category":"page"},{"location":"man/boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"displacement2velocity!(stokes, dt) # convert displacement to velocity\nupdate_halo!(@velocity(stokes)...)","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/PTsolvers/JustRelax.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"JustRelax.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"JustRelax.jl and its contributions are licensed under the MIT license. As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"man/contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"man/subduction2D/setup/#Model-setup","page":"Model setup","title":"Model setup","text":"","category":"section"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"As described in the original paper, the domain consists of a Cartesian box of Omega in 0 3000 times 0 -660 km, with two 80 km thick oceanic plates over the asthenospheric mantle.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"We will use GeophysicalModelGenerator.jl to generate the initial geometry, material phases, and thermal field of our models. We will start by defining the dimensions and resolution of our model, as well as initializing the Grid2D object and two arrays Phases and Temp that host the material phase (given by an integer) and the thermal field, respectively.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"nx, nz        = 512, 218 # number of cells per dimension\nTbot          = 1474.0   # [Celsius]\nmodel_depth   = 660      # [km]\nair_thickness = 10       # [km]\nLx            = 3000     # model length [km]\nx             = range(0, Lx, nx);\nz             = range(-model_depth, air_thickness, nz);\nGrid2D        = CartData(xyz_grid(x,0,z))\nPhases        = zeros(Int64, nx, 1, nz);\nTemp          = fill(Tbot, nx, 1, nz);","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"In this model we have four material phases with their respective phase numbers:","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"Material Phase number\nasthenosphere 0\noceanic lithosphere 1\noceanic crust 3\nsticky air 4","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"We will start by initializing the model as asthenospheric mantle, with a thermal profile given by the half-space cooling model with an age of 80 Myrs.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"add_box!(\n    Phases,\n    Temp,\n    Grid2D;\n    xlim    = (0, Lx),\n    zlim    = (-model_depth, 0.0),\n    phase   = LithosphericPhases(Layers=[], Phases=[0]),\n    T       = HalfspaceCoolingTemp(Tsurface=20, Tmantle=Tbot, Age=80,Adiabat=0.4)\n)","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"(Image: )","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"Next we add a horizontal 80 km thick oceanic lithosphere. Note that we leave a 100 km buffer zone next to the vertical boundaries of the domain, to facilitate the sliding of the oceanic plates.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"add_box!(\n    Phases,\n    Temp,\n    Grid2D;\n    xlim    = (100, Lx-100), # 100 km buffer zones on both sides\n    zlim    = (-model_depth, 0.0),\n    phase   = LithosphericPhases(Layers=[80], Phases=[1 0]),\n    T       = HalfspaceCoolingTemp(Tsurface=20, Tmantle=Tbot, Age=80, Adiabat=0.4)\n)","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"(Image: )","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"As in the original paper, we add a 8km thick crust on top of the subducting oceanic plate.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"# Add right oceanic plate crust\nadd_box!(\n    Phases,\n    Temp,\n    Grid2D;\n    xlim    = (Lx-1430, Lx-200),\n    zlim    = (-model_depth, 0.0),\n    Origin  = nothing, StrikeAngle=0, DipAngle=0,\n    phase   = LithosphericPhases(Layers=[8 72], Phases=[2 1 0]),\n    T       = HalfspaceCoolingTemp(Tsurface=20, Tmantle=Tbot, Age=80, Adiabat=0.4)\n)","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"(Image: )","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"And finally we add the subducting slab, with the trench located at 1430km from the right-hand-side boundary.","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"add_box!(\n    Phases,\n    Temp,\n    Grid2D;\n    xlim    = (Lx-1430, Lx-1430-250),\n    zlim    = (-80, 0.0),\n    Origin  = nothing, StrikeAngle=0, DipAngle=-30,\n    phase   = LithosphericPhases(Layers=[8 72], Phases=[2 1 0]),\n    T       = HalfspaceCoolingTemp(Tsurface=20, Tmantle=Tbot, Age=80, Adiabat=0.4)\n)","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"(Image: )","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"surf                 = Grid2D.z.val .> 0.0\n@views Temp[surf]   .= 20.0\n@views Phases[surf] .= 3","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"(Image: )","category":"page"},{"location":"man/subduction2D/setup/","page":"Model setup","title":"Model setup","text":"li     = (abs(last(x)-first(x)), abs(last(z)-first(z))) .* 1e3 # in meters\norigin = (x[1], z[1]) .* 1e3 # lower-left corner of the domain\nPhases = Phases[:,1,:] .+ 1  # +1 because Julia is 1-indexed\nTemp   = Temp[:,1,:].+273    # in Kelvin","category":"page"},{"location":"man/equations/#Pseudo-transient-iterative-method","page":"Equations","title":"Pseudo-transient iterative method","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"The pseudo-transient method consists in augmenting the right-hand-side of the target PDE with a pseudo-time derivative (where psi is the pseudo-time) of the primary variables. We then solve the resulting system of equations with an iterative method. The pseudo-time derivative is then gradually reduced, until the original PDE is solved and the changes in the primary variables are below a preset tolerance.","category":"page"},{"location":"man/equations/#Heat-diffusion","page":"Equations","title":"Heat diffusion","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"The pseudo-transient heat-diffusion equation is:","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"widetilderhofracpartial Tpartial psi + rho C_p fracpartial Tpartial t = nabla cdot (kappanabla T) = -nabla q","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"We use a second order pseudo-transient scheme were continuation is also done on the flux, so that:","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"widetildethetafracpartial qpartial psi + q  = -kappanabla T","category":"page"},{"location":"man/equations/#Stokes-equations","page":"Equations","title":"Stokes equations","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"For example, the pseudo-transient formulation of the Stokes equations yields:","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"widetilderhofracpartial boldsymbolupartial psi + nablacdotboldsymboltau - nabla p = boldsymbolf","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"frac1widetildeKfracpartial ppartial psi + nablacdotboldsymbolv = beta fracpartial ppartial t + alpha fracpartial Tpartial t","category":"page"},{"location":"man/equations/#Constitutive-equations","page":"Equations","title":"Constitutive equations","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"A pseudo-transient continuation is also done on the constitutive law:","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"frac12widetildeG fracpartialboldsymboltaupartialpsi+ frac12GfracDboldsymboltauDt + fracboldsymboltau2eta = dotboldsymbolvarepsilon","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"where the wide tile denotes the effective damping coefficients and psi is the pseudo-time step. These are defined as in Räss et al. (2022):","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"widetilderho = RefracetawidetildeVL qquad widetildeG = fracwidetilderho widetildeV^2r+2 qquad widetildeK = r widetildeG","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"and","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"widetildeV = sqrt fracwidetildeK +2widetildeGwidetilderho qquad r = fracwidetildeKwidetildeG qquad Re = fracwidetilderhowidetildeVLeta","category":"page"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"where the P-wave widetildeV=V_p is the characteristic velocity scale for Stokes, and Re is the Reynolds number.","category":"page"},{"location":"man/equations/#Physical-parameters","page":"Equations","title":"Physical parameters","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"Symbol Parameter\nT Temperature\nq Flux\nboldsymboltau Deviatoric stress\ndotboldsymbolvarepsilon Deviatoric strain rate\nboldsymbolu Velocity\nboldsymbolf External forces\nP Pressure\neta Viscosity\nrho Density\nbeta Compressibility\nG Shear modulus\nalpha Thermal expansivity\nC_p Heat capacity\nkappa Heat conductivity","category":"page"},{"location":"man/equations/#Pseudo-transient-parameters","page":"Equations","title":"Pseudo-transient parameters","text":"","category":"section"},{"location":"man/equations/","page":"Equations","title":"Equations","text":"Symbol Parameter\npsi Pseudo time step\nwidetildeK Pseudo bulk modulus\nwidetildeG Pseudo shear modulus\nwidetildeV Characteristic velocity scale\nwidetilderho Pseudo density\nwidetildetheta Relaxation time\nRe Reynolds number","category":"page"},{"location":"man/ShearBands/#ShearBand-benchmark","page":"Shear Bands","title":"ShearBand benchmark","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Band benchmark to test the visco-elasto-plastic rheology implementation in JustRelax.jl","category":"page"},{"location":"man/ShearBands/#Initialize-packages","page":"Shear Bands","title":"Initialize packages","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Load JustRelax.jl necessary modules and define backend.","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GeoParams","category":"page"},{"location":"man/ShearBands/#Script","page":"Shear Bands","title":"Script","text":"","category":"section"},{"location":"man/ShearBands/#Model-domain","page":"Shear Bands","title":"Model domain","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"nx = ny      = 64                       # number of cells per dimension\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly                       # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt           = Inf","category":"page"},{"location":"man/ShearBands/#Physical-properties-using-GeoParams","page":"Shear Bands","title":"Physical properties using GeoParams","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"τ_y     = 1.6           # yield stress. If do_DP=true, τ_y stand for the cohesion: c*cos(ϕ)\nϕ       = 30            # friction angle\nC       = τ_y           # Cohesion\nη0      = 1.0           # viscosity\nG0      = 1.0           # elastic shear modulus\nGi      = G0/(6.0-4.0)  # elastic shear modulus perturbation\nεbg     = 1.0           # background strain-rate\nη_reg   = 8e-3          # regularisation \"viscosity\"\ndt      = η0/G0/4.0     # assumes Maxwell time of 4\nel_bg   = ConstantElasticity(; G=G0, Kb=4)\nel_inc  = ConstantElasticity(; G=Gi, Kb=4)\nvisc    = LinearViscous(; η=η0)\npl      = DruckerPrager_regularised(;  # non-regularized plasticity\n    C    = C,\n    ϕ    = ϕ,\n    η_vp = η_reg,\n    Ψ    = 0\n)","category":"page"},{"location":"man/ShearBands/#Rheology","page":"Shear Bands","title":"Rheology","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    rheology = (\n        # Low density phase\n        SetMaterialParams(;\n            Phase             = 1,\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_bg, pl)),\n            Elasticity        = el_bg,\n\n        ),\n        # High density phase\n        SetMaterialParams(;\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_inc, pl)),\n            Elasticity        = el_inc,\n        ),\n    )","category":"page"},{"location":"man/ShearBands/#Phase-anomaly","page":"Shear Bands","title":"Phase anomaly","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"function init_phases!(phase_ratios, xci, radius)\n    ni      = size(phase_ratios.center)\n    origin  = 0.5, 0.5\n\n    @parallel_indices (i, j) function init_phases!(phases, xc, yc, o_x, o_y, radius)\n        x, y = xc[i], yc[j]\n        if ((x-o_x)^2 + (y-o_y)^2) > radius^2\n            JustRelax.@cell phases[1, i, j] = 1.0\n            JustRelax.@cell phases[2, i, j] = 0.0\n\n        else\n            JustRelax.@cell phases[1, i, j] = 0.0\n            JustRelax.@cell phases[2, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phase_ratios.center, xci..., origin..., radius)\nend\n","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\ninit_phases!(phase_ratios, xci, radius)","category":"page"},{"location":"man/ShearBands/#Stokes-arrays","page":"Shear Bands","title":"Stokes arrays","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Stokes arrays object","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/ShearBands/#Initialize-viscosity-fields","page":"Shear Bands","title":"Initialize viscosity fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/ShearBands/#Boundary-conditions","page":"Shear Bands","title":"Boundary conditions","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    flow_bcs     = VelocityBoundaryConditions(;\n        free_slip = (left = true, right = true, top = true, bot = true),\n        no_slip   = (left = false, right = false, top = false, bot=false),\n    )\n    stokes.V.Vx .= PTArray(backend_JR)([ x*εbg for x in xvi[1], _ in 1:ny+2])\n    stokes.V.Vy .= PTArray(backend_JR)([-y*εbg for _ in 1:nx+2, y in xvi[2]])\n    flow_bcs!(stokes, flow_bcs) # apply boundary conditions\n    update_halo!(@velocity(stokes)...)\n","category":"page"},{"location":"man/ShearBands/#Pseuo-transient-coefficients","page":"Shear Bands","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)","category":"page"},{"location":"man/ShearBands/#Just-before-solving-the-problem...","page":"Shear Bands","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"In this benchmark we want to keep track of τII, the total time ttot, and the analytical elastic solution sol","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" solution(ε, t, G, η) = 2 * ε * η * (1 - exp(-G * t / η))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and store their time history in the vectors:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    τII        = Float64[]\n    sol        = Float64[]\n    ttot       = Float64[]","category":"page"},{"location":"man/ShearBands/#Advancing-one-time-step","page":"Shear Bands","title":"Advancing one time step","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Solve stokes","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    dt,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"calculate the second invariant and push to history vectors","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"tensor_invariant!(stokes.ε)\npush!(τII, maximum(stokes.τ.xx))\n\n\nit += 1\nt  += dt\n\npush!(sol, solution(εbg, t, G0, η0))\npush!(ttot, t)","category":"page"},{"location":"man/ShearBands/#Visualization","page":"Shear Bands","title":"Visualization","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GLMakie","category":"page"},{"location":"man/ShearBands/#Fields","page":"Shear Bands","title":"Fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" # visualisation of high density inclusion\nth    = 0:pi/50:3*pi;\nxunit = @. radius * cos(th) + 0.5;\nyunit = @. radius * sin(th) + 0.5;\n\nfig   = Figure(size = (1600, 1600), title = \"t = $t\")\nax1   = Axis(fig[1,1], aspect = 1, title = L\"\\tau_{II}\", titlesize=35)\nax2   = Axis(fig[2,1], aspect = 1, title = L\"E_{II}\", titlesize=35)\nax3   = Axis(fig[1,2], aspect = 1, title = L\"\\log_{10}(\\varepsilon_{II})\", titlesize=35)\nax4   = Axis(fig[2,2], aspect = 1)\nheatmap!(ax1, xci..., Array(stokes.τ.II) , colormap=:batlow)\nheatmap!(ax2, xci..., Array(log10.(stokes.EII_pl)) , colormap=:batlow)\nheatmap!(ax3, xci..., Array(log10.(stokes.ε.II)) , colormap=:batlow)\nlines!(ax2, xunit, yunit, color = :black, linewidth = 5)\nlines!(ax4, ttot, τII, color = :black)\nlines!(ax4, ttot, sol, color = :red)\nhidexdecorations!(ax1)\nhidexdecorations!(ax3)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/ShearBands/#Final-model","page":"Shear Bands","title":"Final model","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Bands evolution in a 2D visco-elasto-plastic rheology model (Image: Shearbands)","category":"page"},{"location":"man/authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"man/authors/","page":"Authors","title":"Authors","text":"JustRelax.jl's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about JustRelax.jl. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The JustRelax.jl Authors\".","category":"page"},{"location":"man/authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"man/authors/","page":"Authors","title":"Authors","text":"Albert de Montserrat, Institute for Geophysics, ETH Zurich, Switzerland\nPascal Aellig, Institute for Geosciences, Johannes Gutenberg University Mainz, Germany","category":"page"},{"location":"man/authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"man/authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to JustRelax.jl and are listed in alphabetical order:","category":"page"},{"location":"man/authors/","page":"Authors","title":"Authors","text":"Sidney Beeler\nLukas Fuchs\nBoris Kaus\nPatrick Sanan\nHendrik Ranocha\nLudovic Räss","category":"page"},{"location":"man/code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"EditURL = \"https://github.com/PTsolvers/JustRelax.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"man/code_of_conduct/#code-of-conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"man/code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Albert de Montserrat, Pascal Aellig, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"man/subduction2D/rheology/#Using-GeoParams.jl-to-define-the-rheology-of-the-material-phases","page":"Rheology","title":"Using GeoParams.jl to define the rheology of the material phases","text":"","category":"section"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"We will use the same physical parameters as the ones defined in Hummel et al 2024.","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"The thermal expansion coefficient alpha and heat capacity C_p are the same for all the material phases","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"α  = 2.4e-5 # 1 / K\nCp = 750    # J / kg K","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"The density of all the phases is constant, except for the oceanic lithosphere, which uses the pressure and temperature dependent equation of state rho = rho_0 left(1 - alpha (T-T_0) - beta (P-P_0) right), where rho_0 = rho (T=1475 textC^circ)=3200 textkgm^3.which corresponds to the PT_Density object from GeoParams.jl:","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"density_lithosphere = PT_Density(; ρ0=3.2e3, α = α, β = 0e0, T0 = 273+1474)","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"We will run the case where the rheology is given by a combination of dislocation and diffusion creep for wet olivine,","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"using GeoParams.Dislocation\nusing GeoParams.Diffusion\ndisl_wet_olivine  = SetDislocationCreep(Dislocation.wet_olivine1_Hirth_2003)\ndiff_wet_olivine  = SetDiffusionCreep(Diffusion.wet_olivine_Hirth_2003)","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"and where plastic failure is given by the formulation from Duretz et al, 2021","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"# non-regularized plasticity\nϕ               = asind(0.1)\nC               = 1e6        # Pa\nplastic_model   = DruckerPrager_regularised(; C = C, ϕ = ϕ, η_vp=η_reg, Ψ=0.0)","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"Finally we define the rheology objects of GeoParams.jl","category":"page"},{"location":"man/subduction2D/rheology/","page":"Rheology","title":"Rheology","text":"rheology = (\n    SetMaterialParams(;\n        Name              = \"Asthenoshpere\",\n        Phase             = 1,\n        Density           = ConstantDensity(; ρ=3.2e3),\n        HeatCapacity      = ConstantHeatCapacity(; Cp = Cp),\n        Conductivity      = ConstantConductivity(; k  = 2.5),\n        CompositeRheology = CompositeRheology( (LinearViscous(; η=1e20),)),\n        Gravity           = ConstantGravity(; g=9.81),\n    ),\n    SetMaterialParams(;\n        Name              = \"Oceanic lithosphere\",\n        Phase             = 2,\n        Density           = density_lithosphere,\n        HeatCapacity      = ConstantHeatCapacity(; Cp = Cp),\n        Conductivity      = ConstantConductivity(; k  = 2.5),\n        CompositeRheology = CompositeRheology(\n            (\n                disl_wet_olivine,\n                diff_wet_olivine,\n                plastic_model,\n            )\n        ),\n    ),\n    SetMaterialParams(;\n        Name              = \"oceanic crust\",\n        Phase             = 3,\n        Density           = ConstantDensity(; ρ=3.2e3),\n        HeatCapacity      = ConstantHeatCapacity(; Cp = Cp),\n        Conductivity      = ConstantConductivity(; k  = 2.5),\n        CompositeRheology = CompositeRheology( (LinearViscous(; η=1e20),)),\n    ),\n    SetMaterialParams(;\n        Name              = \"StickyAir\",\n        Phase             = 4,\n        Density           = ConstantDensity(; ρ=1), # water density\n        HeatCapacity      = ConstantHeatCapacity(; Cp = 1e34),\n        Conductivity      = ConstantConductivity(; k  = 3),\n        CompositeRheology = CompositeRheology((LinearViscous(; η=1e19),)),\n    ),\n)","category":"page"},{"location":"man/subduction2D/subduction2D/#2D-subduction","page":"Setting up the model","title":"2D subduction","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Model setups taken from Hummel et al 2024.","category":"page"},{"location":"man/subduction2D/subduction2D/#Model-setup","page":"Setting up the model","title":"Model setup","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We will use GeophysicalModelGenerator.jl to generate the initial geometry, material phases, and thermal field of our models.","category":"page"},{"location":"man/subduction2D/subduction2D/#Initialize-packages","page":"Setting up the model","title":"Initialize packages","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Load JustRelax necessary modules and define backend.","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"using CUDA # comment this out if you are not using CUDA; or load AMDGPU.jl if you are using an AMD GPU\nusing JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CUDABackend  # Options: CPUBackend, CUDABackend, AMDGPUBackend","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"For this benchmark we will use particles to track the advection of the material phases and their information. For this, we will use JustPIC.jl","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"using JustPIC, JustPIC._2D\nconst backend = CUDABackend # Options: JustPIC.CPUBackend, CUDABackend, JustPIC.AMDGPUBackend","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"using ParallelStencil\n@init_parallel_stencil(CUDA, Float64, 2)","category":"page"},{"location":"man/subduction2D/subduction2D/#Helper-function","page":"Setting up the model","title":"Helper function","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We first define a helper function that will be useful later on","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"function copyinn_x!(A, B)\n    @parallel function f_x(A, B)\n        @all(A) = @inn_x(B)\n        return nothing\n    end\n\n    @parallel f_x(A, B)\nend","category":"page"},{"location":"man/subduction2D/subduction2D/#Script","page":"Setting up the model","title":"Script","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/#Model-domain","page":"Setting up the model","title":"Model domain","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"nx, ny        = 256, 128         # number of cells in x and y directions\nni            = nx, ny\ndi            = @. li / ni       # grid steps\ngrid          = Geometry(ni, li; origin = origin)\n(; xci, xvi)  = grid # nodes at the center and vertices of the cells","category":"page"},{"location":"man/subduction2D/subduction2D/#Physical-properties-using-GeoParams","page":"Setting up the model","title":"Physical properties using GeoParams","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"For the rheology we will use the rheology object we created in the previous section.","category":"page"},{"location":"man/subduction2D/subduction2D/#Initialize-particles","page":"Setting up the model","title":"Initialize particles","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"nxcell              = 40 # initial number of particles per cell\nmax_xcell           = 60 # maximum number of particles per cell\nmin_xcell           = 20 # minimum number of particles per cell\n    particles = init_particles(\n        backend, nxcell, max_xcell, min_xcell, xvi...\n    )\n)\nsubgrid_arrays      = SubgridDiffusionCellArrays(particles)\n# velocity staggered grids\ngrid_vxi            = velocity_grids(xci, xvi, di)","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We will like to advect two fields, the temperature pT and the material phases of each particle pPhases. We will initialize these fields as CellArray objects:","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"pPhases, pT         = init_cell_arrays(particles, Val(2))\nparticle_args       = (pT, pPhases)","category":"page"},{"location":"man/subduction2D/subduction2D/#Assign-particles-phases-anomaly","page":"Setting up the model","title":"Assign particles phases anomaly","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Now we assign the material phases from the arrays we computed with help of GeophysicalModelGenerator.jl","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"phases_device    = PTArray(backend)(phases_GMG)\nphase_ratios     = PhaseRatio(backend, ni, length(rheology))\ninit_phases!(pPhases, phases_device, particles, xvi)\nphase_ratios_center!(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/subduction2D/subduction2D/#Temperature-profile","page":"Setting up the model","title":"Temperature profile","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We need to copy the thermal field from the GeophysicalModelGenerator.jl object to the thermal that contains all the arrays related to the thermal field.","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Ttop             = 20 + 273\nTbot             = maximum(T_GMG)\nthermal          = ThermalArrays(backend, ni)\n@views thermal.T[2:end-1, :] .= PTArray(backend)(T_GMG)\nthermal_bc       = TemperatureBoundaryConditions(;\n    no_flux      = (left = true, right = true, top = false, bot = false),\n)\nthermal_bcs!(thermal, thermal_bc)\n@views thermal.T[:, end] .= Ttop\n@views thermal.T[:, 1]   .= Tbot\ntemperature2center!(thermal)","category":"page"},{"location":"man/subduction2D/subduction2D/#Stokes-arrays","page":"Setting up the model","title":"Stokes arrays","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Stokes arrays object","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"stokes           = StokesArrays(backend, ni)\npt_stokes        = PTStokesCoeffs(li, di; ϵ=1e-4, Re=3π, r=1e0, CFL = 1 / √2.1) # Re=3π, r=0.7","category":"page"},{"location":"man/subduction2D/subduction2D/#Buoyancy-forces-and-lithostatic-pressure","page":"Setting up the model","title":"Buoyancy forces and lithostatic pressure","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"ρg        = ntuple(_ -> @zeros(ni...), Val(2))\ncompute_ρg!(ρg[2], phase_ratios, rheology_augmented, (T=thermal.Tc, P=stokes.P))\nstokes.P .= PTArray(backend)(reverse(cumsum(reverse((ρg[2]).* di[2], dims=2), dims=2), dims=2))","category":"page"},{"location":"man/subduction2D/subduction2D/#Viscosity","page":"Setting up the model","title":"Viscosity","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"args0            = (T=thermal.Tc, P=stokes.P, dt = Inf)\nviscosity_cutoff = (1e17, 1e24)\ncompute_viscosity!(stokes, phase_ratios, args0, rheology, viscosity_cutoff)","category":"page"},{"location":"man/subduction2D/subduction2D/#Boundary-conditions","page":"Setting up the model","title":"Boundary conditions","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"We we will use free slip boundary conditions on all sides","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"# Boundary conditions\nflow_bcs         = VelocityBoundaryConditions(;\n    free_slip    = (left = true , right = true , top = true , bot = true),\n)","category":"page"},{"location":"man/subduction2D/subduction2D/#Pseuo-transient-coefficients","page":"Setting up the model","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"pt_thermal = PTThermalCoeffs(\n    backend, rheology_augmented, phase_ratios, args0, dt, ni, di, li; ϵ=1e-5, CFL=1e-3 / √3\n)","category":"page"},{"location":"man/subduction2D/subduction2D/#Just-before-solving-the-problem...","page":"Setting up the model","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Because we have ghost nodes on the thermal field thermal.T, we need to copy the thermal field to a buffer array without those ghost nodes, and interpolate the temperature to the particles. This is because JustPIC.jl does not support ghost nodes yet.","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"T_buffer    = @zeros(ni.+1)\nTold_buffer = similar(T_buffer)\ndt₀         = similar(stokes.P)\nfor (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\ngrid2particle!(pT, xvi, T_buffer, particles)","category":"page"},{"location":"man/subduction2D/subduction2D/#Advancing-one-time-step","page":"Setting up the model","title":"Advancing one time step","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Interpolate fields from particle to grid vertices","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"particle2grid!(T_buffer, pT, xvi, particles)\n@views T_buffer[:, end]      .= Ttop\n@views T_buffer[:, 1]        .= Tbot\n@views thermal.T[2:end-1, :] .= T_buffer\nthermal_bcs!(thermal, thermal_bc)\ntemperature2center!(thermal)","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Solve stokes","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":" t_stokes = @elapsed begin\n    out = solve!(\n        stokes,\n        pt_stokes,\n        di,\n        flow_bcs,\n        ρg,\n        phase_ratios,\n        rheology_augmented,\n        args,\n        dt,\n        igg;\n        kwargs = (\n            iterMax          = 150e3,\n            nout             = 1e3,\n            viscosity_cutoff = viscosity_cutoff,\n            free_surface     = false,\n            viscosity_relaxation = 1e-2\n        )\n    );\nend\nprintln(\"Stokes solver time             \")\nprintln(\"   Total time:      $t_stokes s\")\nprintln(\"   Time/iteration:  $(t_stokes / out.iter) s\")","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Update time step","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"dt = compute_dt(stokes, di) * 0.8","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Thermal solver and subgrid diffusion","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"heatdiffusion_PT!(\n    thermal,\n    pt_thermal,\n    thermal_bc,\n    rheology_augmented,\n    args,\n    dt,\n    di;\n    kwargs = (\n        igg     = igg,\n        phase   = phase_ratios,\n        iterMax = 50e3,\n        nout    = 1e2,\n        verbose = true,\n    )\n)\nsubgrid_characteristic_time!(\n    subgrid_arrays, particles, dt₀, phase_ratios, rheology_augmented, thermal, stokes, xci, di\n)\ncentroid2particle!(subgrid_arrays.dt₀, xci, dt₀, particles)\nsubgrid_diffusion!(\n    pT, thermal.T, thermal.ΔT, subgrid_arrays, particles, xvi,  di, dt\n)","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Particles advection","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"# advect particles in space\nadvection!(particles, RungeKutta2(), @velocity(stokes), grid_vxi, dt)\n# advect particles in memory\nmove_particles!(particles, xvi, particle_args)\n# check if we need to inject particles\ninject_particles_phase!(particles, pPhases, (pT, ), (T_buffer, ), xvi)\n# update phase ratios\nphase_ratios_center!(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Optional: Save data as VTK to visualize it later with ParaView","category":"page"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Vx_v = @zeros(ni.+1...)\nVy_v = @zeros(ni.+1...)\nvelocity2vertex!(Vx_v, Vy_v, @velocity(stokes)...) # interpolate velocity from staggered grid to vertices\ndata_v = (; # data @ vertices\n    T   = Array(T_buffer),\n    τII = Array(stokes.τ.II),\n    εII = Array(stokes.ε.II),\n    Vx  = Array(Vx_v),\n    Vy  = Array(Vy_v),\n)\ndata_c = (; # data @ centers\n    P   = Array(stokes.P),\n    η   = Array(stokes.viscosity.η_vep),\n)\nvelocity_v = ( # velocity vector field\n    Array(Vx_v),\n    Array(Vy_v),\n)\nsave_vtk(\n    joinpath(@__DIR__, \"vtk_\" * lpad(\"$it\", 6, \"0\")),\n    xvi,\n    xci,\n    data_v,\n    data_c,\n    velocity_v\n)","category":"page"},{"location":"man/subduction2D/subduction2D/#Final-model","page":"Setting up the model","title":"Final model","text":"","category":"section"},{"location":"man/subduction2D/subduction2D/","page":"Setting up the model","title":"Setting up the model","text":"Solution after 990 time steps (Image: )","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here an overview of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [JustRelax, JustRelax.JustRelax2D, JustRelax.JustRelax3D, JustRelax.DataIO]","category":"page"},{"location":"man/listfunctions/#JustRelax.Geometry","page":"List of functions","title":"JustRelax.Geometry","text":"struct Geometry{nDim,T}\n\nA struct representing the geometry of a topological object in nDim dimensions.\n\nArguments\n\nnDim: The number of dimensions of the topological object.\nT: The type of the elements in the topological object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.cart2ind-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{Int64, N1}}, Vararg{Int64, N2}}} where {N1, N2}","page":"List of functions","title":"JustRelax.cart2ind","text":"cart2ind(A)\n\nReturn the linear index of a n-dimensional array corresponding to the cartesian indices I\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.element-Union{Tuple{D}, Tuple{Nc}, Tuple{N}, Tuple{T_elem}, Tuple{CellArrays.CellArray{StaticArraysCore.SVector, N, D, T_elem}, Int64, Vararg{Int64, Nc}}} where {T_elem, N, Nc, D}","page":"List of functions","title":"JustRelax.element","text":"element(A, element_indices..., cell_indices...)\n\nReturn a the element with element_indices of the Cell with cell_indices of the CellArray A.\n\nArguments\n\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.setelement!-Union{Tuple{D}, Tuple{T_elem}, Tuple{N}, Tuple{T}, Tuple{N_array}, Tuple{Nj}, Tuple{Ni}, Tuple{Nc}, Tuple{CellArrays.CellArray{StaticArraysCore.SMatrix{Ni, Nj, T, N_array}, N, D, T_elem}, T, Any, Any, Vararg{Int64, Nc}}} where {Nc, Ni, Nj, N_array, T, N, T_elem, D}","page":"List of functions","title":"JustRelax.setelement!","text":"setelement!(A, x, element_indices..., cell_indices...)\n\nStore the given value x at the given element with element_indices of the cell with the indices cell_indices\n\nArguments\n\nx::Number: value to be stored in the index element_indices of the cell with cell_indices.\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.velocity_grids-Union{Tuple{T}, Tuple{Any, Any, Tuple{T, T}}} where T","page":"List of functions","title":"JustRelax.velocity_grids","text":"velocity_grids(xci, xvi, di::NTuple{N,T}) where {N,T}\n\nCompute the velocity grids for N dimensionional problems.\n\nArguments\n\nxci: The x-coordinate of the cell centers.\nxvi: The x-coordinate of the cell vertices.\ndi: A tuple containing the cell dimensions.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.WENO5","page":"List of functions","title":"JustRelax.JustRelax2D.WENO5","text":"WENO5{T, N, A, M} <: AbstractWENO\n\nThe WENO5 is a structure representing the Weighted Essentially Non-Oscillatory (WENO) scheme of order 5 for the solution of hyperbolic partial differential equations.\n\nFields\n\nd0L, d1L, d2L: Upwind constants.\nd0R, d1R, d2R: Downwind constants.\nc1, c2: Constants for betas.\nsc1, sc2, sc3, sc4, sc5: Stencil weights.\nϵ: Tolerance.\nni: Grid size.\nut: Intermediate buffer array.\nfL, fR, fB, fT: Fluxes.\nmethod: Method (1:JS, 2:Z).\n\nDescription\n\nThe WENO5 structure contains the parameters and temporary variables used in the WENO scheme. These include the upwind and downwind constants, the constants for betas, the stencil candidate weights, the tolerance, the grid size, the fluxes, and the method.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.WENO_advection!-NTuple{5, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.WENO_advection!","text":"WENO_advection!(u, Vxi, weno, di, ni, dt)\n\nPerform the advection step of the Weighted Essentially Non-Oscillatory (WENO) scheme for the solution of hyperbolic partial differential equations.\n\nArguments\n\nu: field to be advected.\nVxi: velocity field.\nweno: structure containing the WENO scheme parameters and temporary variables.\ndi: grid spacing.\nni: number of grid points.\ndt: time step.\n\nDescription\n\nThe function first calculates the fluxes using the WENO scheme. Then it performs three steps of the WENO scheme. Each step involves calculating the right-hand side of the WENO equation and updating the solution u. The updating of the solution u is done using different combinations of the original solution and the temporary solution weno.ut.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, AbstractArray, AbstractArray, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, K, ρCp, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations. Both K and ρCp are n-dimensional arrays.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, Any, NamedTuple, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, rheology, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.allzero-Union{Tuple{Vararg{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax2D.allzero","text":"allzero(x::Vararg{T,N}) where {T,N}\n\nCheck if all elements in x are zero.\n\nArguments\n\nx::Vararg{T,N}: The input array.\n\nReturns\n\nBool: true if all elements in x are zero, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.assign!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax2D.assign!","text":"assign!(B::AbstractArray{T,N}, A::AbstractArray{T,N}) where {T,N}\n\nAssigns the values of array A to array B in parallel.\n\nArguments\n\nB::AbstractArray{T,N}: The destination array.\nA::AbstractArray{T,N}: The source array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_P!-Union{Tuple{N}, Tuple{Any, Any, Any, Any, Any, Tuple{Vararg{GeoParams.MaterialParameters.MaterialParams, N}}, Any, Any, Any, Any, NamedTuple}} where N","page":"List of functions","title":"JustRelax.JustRelax2D.compute_P!","text":"computeP!(P, P0, RP, ∇V, ΔTc, η, rheology::NTuple{N,MaterialParams}, phaseratio::C, dt, r, θ_dτ)\n\nCompute the pressure field P and the residual RP for the compressible case. This function introduces thermal stresses after the implementation of Kiss et al. (2023). The temperature difference ΔTc on the cell center is used to compute this as well as α as the thermal expansivity.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology, args, phase_ratios)\n\nCompute the buoyancy forces based on the given rheology, arguments, and phase ratios.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required by the rheology.\nphase_ratios: The ratios of the different phases.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology, args)\n\nCompute the buoyancy forces based on the given rheology and arguments.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args, phase_ratios)\n\nCompute the buoyancy forces for a given set of material parameters, arguments, and phase ratios.\n\nArguments\n\nrheology: The material parameters.\nargs: The arguments.\nphase_ratios: The phase ratios.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args)\n\nCompute the buoyancy forces based on the given rheology parameters and arguments.\n\nArguments\n\nrheology::MaterialParams: The material parameters for the rheology.\nargs: The arguments for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_dt-Tuple{JustRelax.StokesArrays, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, args...)\n\nCompute the time step dt for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_maxloc!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_maxloc!","text":"maxloc!(B, A; window)\n\nCompute the maximum value of A in the window = (width_x, width_y, width_z) and store the result in B.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_ρg!-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_ρg!","text":"compute_ρg!(ρg, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_ρg!-Tuple{Any, JustRelax.PhaseRatio, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_ρg!","text":"compute_ρg!(ρg, phase_ratios, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.  The phase_ratios are used to compute the density of the composite rheology.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.continuation_log-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"List of functions","title":"JustRelax.JustRelax2D.continuation_log","text":"continuation_log(x_new, x_old, ν)\n\nDo a continuation step exp((1-ν)*log(x_old) + ν*log(x_new)) with damping parameter ν\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.flow_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.flow_bcs!","text":"flow_bcs!(stokes, bcs::VelocityBoundaryConditions)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.flow_bcs!-Tuple{CPUBackendTrait, Any, DisplacementBoundaryConditions}","page":"List of functions","title":"JustRelax.JustRelax2D.flow_bcs!","text":"flow_bcs!(stokes, bcs::DisplacementBoundaryConditions)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.fn_ratio-Union{Tuple{F}, Tuple{N}, Tuple{F, Tuple{Vararg{GeoParams.AbstractMaterialParamsStruct, N}}, Any}} where {N, F}","page":"List of functions","title":"JustRelax.JustRelax2D.fn_ratio","text":"fn_ratio(fn::F, rheology::NTuple{N, AbstractMaterialParamsStruct}, ratio) where {N, F}\n\nAverage the function fn over the material phases in rheology using the phase ratios ratio.    \n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.interp_Vx_on_Vy!-Tuple{Any, Any, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}","page":"List of functions","title":"JustRelax.JustRelax2D.interp_Vx_on_Vy!","text":"interp_Vx_on_Vy!(Vx_on_Vy, Vx)\n\nInterpolates the values of Vx onto the grid points of Vy.\n\nArguments\n\nVx_on_Vy::AbstractArray: Vx at Vy grid points.\nVx::AbstractArray: Vx at its staggered grid points.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.nphases-Tuple{JustRelax.PhaseRatio}","page":"List of functions","title":"JustRelax.JustRelax2D.nphases","text":"nphases(x::JustRelax.PhaseRatio)\n\nReturn the number of phases in x::JustRelax.PhaseRatio.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.rotate_stress!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Any, Any}} where {N, T}","page":"List of functions","title":"JustRelax.JustRelax2D.rotate_stress!","text":"Jaumann derivative\n\nτijo += vk * ∂τijo/∂xk - ωij * ∂τkjo + ∂τkjo * ωij\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.take-Tuple{String}","page":"List of functions","title":"JustRelax.JustRelax2D.take","text":"take(fldr::String)\n\nCreate folder fldr if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.tensor_invariant!-Tuple{JustRelax.SymmetricTensor}","page":"List of functions","title":"JustRelax.JustRelax2D.tensor_invariant!","text":"tensor_invariant!(A::JustRelax.SymmetricTensor)\n\nCompute the tensor invariant of the given symmetric tensor A.\n\nArguments\n\nA::JustRelax.SymmetricTensor: The input symmetric tensor.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.thermal_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.thermal_bcs!","text":"thermal_bcs!(T, bcs::TemperatureBoundaryConditions)\n\nApply the prescribed heat boundary conditions bc on the T\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.velocity2vertex!-NTuple{6, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.velocity2vertex!","text":"velocity2vertex!(Vx_v, Vy_v, Vz_v, Vx, Vy, Vz)\n\nIn-place interpolation of the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the pre-allocated Vx_d, Vy_d, Vz_d 3D arrays located at the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.velocity2vertex-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.velocity2vertex","text":"velocity2vertex(Vx, Vy, Vz)\n\nInterpolate the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@add-Tuple{Any, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax2D.@add","text":"@add(I, args...)\n\nAdd I to the scalars in args\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@copy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@copy","text":"copy(B, A)\n\nconvenience macro to copy data from the array A into array B\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@displacement-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@displacement","text":"@displacement(U)\n\nUnpacks the displacement arrays U from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@idx-Tuple","page":"List of functions","title":"JustRelax.JustRelax2D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@normal-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@normal","text":"@normal(A)\n\nUnpacks the normal components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@plastic_strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@plastic_strain","text":"@plastic_strain(A)\n\nUnpacks the plastic strain rate tensor ε_pl from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@qT-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@qT","text":"@qT(V)\n\nUnpacks the flux arrays qT_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@qT2-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@qT2","text":"@qT2(V)\n\nUnpacks the flux arrays qT2_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@residuals-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@residuals","text":"@residuals(A)\n\nUnpacks the momentum residuals from A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@shear-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@shear","text":"@shear(A)\n\nUnpacks the shear components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@strain","text":"@strain(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@strain_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@strain_center","text":"@strain_center(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@stress-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@stress","text":"@stress(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@stress_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@stress_center","text":"@stress_center(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@tensor-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@tensor","text":"@tensor(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@tensor_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@tensor_center","text":"@tensor_center(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@velocity-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@velocity","text":"@velocity(V)\n\nUnpacks the velocity arrays V from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.WENO5","page":"List of functions","title":"JustRelax.JustRelax3D.WENO5","text":"WENO5{T, N, A, M} <: AbstractWENO\n\nThe WENO5 is a structure representing the Weighted Essentially Non-Oscillatory (WENO) scheme of order 5 for the solution of hyperbolic partial differential equations.\n\nFields\n\nd0L, d1L, d2L: Upwind constants.\nd0R, d1R, d2R: Downwind constants.\nc1, c2: Constants for betas.\nsc1, sc2, sc3, sc4, sc5: Stencil weights.\nϵ: Tolerance.\nni: Grid size.\nut: Intermediate buffer array.\nfL, fR, fB, fT: Fluxes.\nmethod: Method (1:JS, 2:Z).\n\nDescription\n\nThe WENO5 structure contains the parameters and temporary variables used in the WENO scheme. These include the upwind and downwind constants, the constants for betas, the stencil candidate weights, the tolerance, the grid size, the fluxes, and the method.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.WENO_advection!-NTuple{5, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.WENO_advection!","text":"WENO_advection!(u, Vxi, weno, di, ni, dt)\n\nPerform the advection step of the Weighted Essentially Non-Oscillatory (WENO) scheme for the solution of hyperbolic partial differential equations.\n\nArguments\n\nu: field to be advected.\nVxi: velocity field.\nweno: structure containing the WENO scheme parameters and temporary variables.\ndi: grid spacing.\nni: number of grid points.\ndt: time step.\n\nDescription\n\nThe function first calculates the fluxes using the WENO scheme. Then it performs three steps of the WENO scheme. Each step involves calculating the right-hand side of the WENO equation and updating the solution u. The updating of the solution u is done using different combinations of the original solution and the temporary solution weno.ut.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, AbstractArray, AbstractArray, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, K, ρCp, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations. Both K and ρCp are n-dimensional arrays.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, Any, NamedTuple, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, rheology, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.allzero-Union{Tuple{Vararg{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax3D.allzero","text":"allzero(x::Vararg{T,N}) where {T,N}\n\nCheck if all elements in x are zero.\n\nArguments\n\nx::Vararg{T,N}: The input array.\n\nReturns\n\nBool: true if all elements in x are zero, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.assign!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax3D.assign!","text":"assign!(B::AbstractArray{T,N}, A::AbstractArray{T,N}) where {T,N}\n\nAssigns the values of array A to array B in parallel.\n\nArguments\n\nB::AbstractArray{T,N}: The destination array.\nA::AbstractArray{T,N}: The source array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_P!-Union{Tuple{N}, Tuple{Any, Any, Any, Any, Any, Tuple{Vararg{GeoParams.MaterialParameters.MaterialParams, N}}, Any, Any, Any, Any, NamedTuple}} where N","page":"List of functions","title":"JustRelax.JustRelax3D.compute_P!","text":"computeP!(P, P0, RP, ∇V, ΔTc, η, rheology::NTuple{N,MaterialParams}, phaseratio::C, dt, r, θ_dτ)\n\nCompute the pressure field P and the residual RP for the compressible case. This function introduces thermal stresses after the implementation of Kiss et al. (2023). The temperature difference ΔTc on the cell center is used to compute this as well as α as the thermal expansivity.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology, args, phase_ratios)\n\nCompute the buoyancy forces based on the given rheology, arguments, and phase ratios.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required by the rheology.\nphase_ratios: The ratios of the different phases.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology, args)\n\nCompute the buoyancy forces based on the given rheology and arguments.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args, phase_ratios)\n\nCompute the buoyancy forces for a given set of material parameters, arguments, and phase ratios.\n\nArguments\n\nrheology: The material parameters.\nargs: The arguments.\nphase_ratios: The phase ratios.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args)\n\nCompute the buoyancy forces based on the given rheology parameters and arguments.\n\nArguments\n\nrheology::MaterialParams: The material parameters for the rheology.\nargs: The arguments for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_dt-Tuple{JustRelax.StokesArrays, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, args...)\n\nCompute the time step dt for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_maxloc!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_maxloc!","text":"maxloc!(B, A; window)\n\nCompute the maximum value of A in the window = (width_x, width_y, width_z) and store the result in B.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_ρg!-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_ρg!","text":"compute_ρg!(ρg, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_ρg!-Tuple{Any, JustRelax.PhaseRatio, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_ρg!","text":"compute_ρg!(ρg, phase_ratios, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.  The phase_ratios are used to compute the density of the composite rheology.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.continuation_log-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"List of functions","title":"JustRelax.JustRelax3D.continuation_log","text":"continuation_log(x_new, x_old, ν)\n\nDo a continuation step exp((1-ν)*log(x_old) + ν*log(x_new)) with damping parameter ν\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.flow_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.flow_bcs!","text":"flow_bcs!(stokes, bcs::VelocityBoundaryConditions)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.flow_bcs!-Tuple{CPUBackendTrait, Any, DisplacementBoundaryConditions}","page":"List of functions","title":"JustRelax.JustRelax3D.flow_bcs!","text":"flow_bcs!(stokes, bcs::DisplacementBoundaryConditions)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.fn_ratio-Union{Tuple{F}, Tuple{N}, Tuple{F, Tuple{Vararg{GeoParams.AbstractMaterialParamsStruct, N}}, Any}} where {N, F}","page":"List of functions","title":"JustRelax.JustRelax3D.fn_ratio","text":"fn_ratio(fn::F, rheology::NTuple{N, AbstractMaterialParamsStruct}, ratio) where {N, F}\n\nAverage the function fn over the material phases in rheology using the phase ratios ratio.    \n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.interp_Vx_on_Vy!-Tuple{Any, Any, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}","page":"List of functions","title":"JustRelax.JustRelax3D.interp_Vx_on_Vy!","text":"interp_Vx_on_Vy!(Vx_on_Vy, Vx)\n\nInterpolates the values of Vx onto the grid points of Vy.\n\nArguments\n\nVx_on_Vy::AbstractArray: Vx at Vy grid points.\nVx::AbstractArray: Vx at its staggered grid points.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.nphases-Tuple{JustRelax.PhaseRatio}","page":"List of functions","title":"JustRelax.JustRelax3D.nphases","text":"nphases(x::JustRelax.PhaseRatio)\n\nReturn the number of phases in x::JustRelax.PhaseRatio.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.rotate_stress!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Any, Any}} where {N, T}","page":"List of functions","title":"JustRelax.JustRelax3D.rotate_stress!","text":"Jaumann derivative\n\nτijo += vk * ∂τijo/∂xk - ωij * ∂τkjo + ∂τkjo * ωij\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.take-Tuple{String}","page":"List of functions","title":"JustRelax.JustRelax3D.take","text":"take(fldr::String)\n\nCreate folder fldr if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.tensor_invariant!-Tuple{JustRelax.SymmetricTensor}","page":"List of functions","title":"JustRelax.JustRelax3D.tensor_invariant!","text":"tensor_invariant!(A::JustRelax.SymmetricTensor)\n\nCompute the tensor invariant of the given symmetric tensor A.\n\nArguments\n\nA::JustRelax.SymmetricTensor: The input symmetric tensor.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.thermal_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.thermal_bcs!","text":"thermal_bcs!(T, bcs::TemperatureBoundaryConditions)\n\nApply the prescribed heat boundary conditions bc on the T\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.velocity2vertex!-NTuple{6, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.velocity2vertex!","text":"velocity2vertex!(Vx_v, Vy_v, Vz_v, Vx, Vy, Vz)\n\nIn-place interpolation of the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the pre-allocated Vx_d, Vy_d, Vz_d 3D arrays located at the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.velocity2vertex-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.velocity2vertex","text":"velocity2vertex(Vx, Vy, Vz)\n\nInterpolate the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@add-Tuple{Any, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax3D.@add","text":"@add(I, args...)\n\nAdd I to the scalars in args\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@copy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@copy","text":"copy(B, A)\n\nconvenience macro to copy data from the array A into array B\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@displacement-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@displacement","text":"@displacement(U)\n\nUnpacks the displacement arrays U from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@idx-Tuple","page":"List of functions","title":"JustRelax.JustRelax3D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@normal-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@normal","text":"@normal(A)\n\nUnpacks the normal components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@plastic_strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@plastic_strain","text":"@plastic_strain(A)\n\nUnpacks the plastic strain rate tensor ε_pl from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@qT-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@qT","text":"@qT(V)\n\nUnpacks the flux arrays qT_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@qT2-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@qT2","text":"@qT2(V)\n\nUnpacks the flux arrays qT2_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@residuals-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@residuals","text":"@residuals(A)\n\nUnpacks the momentum residuals from A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@shear-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@shear","text":"@shear(A)\n\nUnpacks the shear components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@strain","text":"@strain(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@strain_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@strain_center","text":"@strain_center(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@stress-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@stress","text":"@stress(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@stress_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@stress_center","text":"@stress_center(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@tensor-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@tensor","text":"@tensor(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@tensor_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@tensor_center","text":"@tensor_center(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@velocity-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@velocity","text":"@velocity(V)\n\nUnpacks the velocity arrays V from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.DataIO.checkpoint_name-Tuple{Any}","page":"List of functions","title":"JustRelax.DataIO.checkpoint_name","text":"checkpointing_jld2(dst, stokes, thermal, time, timestep, igg)\n\nSave necessary data in dst as a jld2 file to restart the model from the state at time. If run in parallel, the file will be named after the corresponidng rank e.g. checkpoint0000.jld2 and thus can be loaded by the processor while restarting the simulation. If you want to restart your simulation from the checkpoint you can use load() and specify the MPI rank by providing a dollar sign and the rank number.\n\nExample\n\n```julia\ncheckpointing_jld2(\n    \"path/to/dst\",\n    stokes,\n    thermal,\n    t,\n    igg,\n)\n\n```\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.checkpointing_hdf5-NTuple{5, Any}","page":"List of functions","title":"JustRelax.DataIO.checkpointing_hdf5","text":"checkpointing_hdf5(dst, stokes, T, η, time, timestep)\n\nSave necessary data in dst as and HDF5 file to restart the model from the state at time\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.load_checkpoint_hdf5-Tuple{Any}","page":"List of functions","title":"JustRelax.DataIO.load_checkpoint_hdf5","text":"load_checkpoint_hdf5(file_path)\n\nLoad the state of the simulation from an .h5 file.\n\nArguments\n\nfile_path: The path to the .h5 file.\n\nReturns\n\nP: The loaded state of the pressure variable.\nT: The loaded state of the temperature variable.\nVx: The loaded state of the x-component of the velocity variable.\nVy: The loaded state of the y-component of the velocity variable.\nVz: The loaded state of the z-component of the velocity variable.\nη: The loaded state of the viscosity variable.\nt: The loaded simulation time.\ndt: The loaded simulation time.\n\nExample\n\n```julia\n\nDefine the path to the .h5 file\n\nfile_path = \"path/to/your/file.h5\"\n\nUse the load_checkpoint function to load the variables from the file\n\nP, T, Vx, Vy, Vz, η, t, dt = load_checkpoint(file_path)`\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.load_checkpoint_jld2-Tuple{Any}","page":"List of functions","title":"JustRelax.DataIO.load_checkpoint_jld2","text":"load_checkpoint_jld2(file_path)\n\nLoad the state of the simulation from a .jld2 file.\n\nArguments\n\nfile_path: The path to the .jld2 file.\n\nReturns\n\nstokes: The loaded state of the stokes variable.\nthermal: The loaded state of the thermal variable.\ntime: The loaded simulation time.\ntimestep: The loaded time step.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.metadata-Tuple{Any, Any, Vararg{Any}}","page":"List of functions","title":"JustRelax.DataIO.metadata","text":"metadata(src, dst, files...)\n\nCopy files..., Manifest.toml, and Project.toml from src to dst\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.save_hdf5-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N","page":"List of functions","title":"JustRelax.DataIO.save_hdf5","text":"function save_hdf5(dst, fname, data)\n\nSave data as the fname.h5 HDF5 file in the folder dst\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.save_hdf5-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N","page":"List of functions","title":"JustRelax.DataIO.save_hdf5","text":"function save_hdf5(fname, data)\n\nSave data as the fname.h5 HDF5 file\n\n\n\n\n\n","category":"method"},{"location":"man/backend/#Selecting-the-backend","page":"Backend","title":"Selecting the backend","text":"","category":"section"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"JustRelax.jl supports three backends: the default CPU backend, and two GPU backends for Nvidia and AMD GPUs. The default CPU backend is selected upon loading JustRelax:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"The GPU backends are implemented as extensions, and can be selected upon loading the appropriate GPU package before loading JustRelax. If running on Nvidia GPUs, use the CUDA.jl package:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using CUDA, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and if running on AMD GPUs, use the AMDGPU.jl package:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using AMDGPU, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"Two and three dimensional solvers are implemented in different submodules, which also need to be loaded. To access the two-dimensional module:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax2D","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and for the three-dimensional module:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax3D","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"JustRelax.jl is a registered package and can be added as follows:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.add(\"JustRelax\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n\n(@v1.10) pkg> add JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"info: Install from a specific branch\nHowever, as the API is changing and not every new feature leads to a new release, one can also clone the main branch of the repository:add JustRelax#main","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"After installation, you can test the package by running the following commands:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using JustRelax\n\njulia> ]\n\n(@v1.10) pkg> test JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The test will take a while, so grab a ☕️ or 🍵","category":"page"},{"location":"man/Blankenbach/#Blankenbach-benchmark","page":"Blankenbach","title":"Blankenbach benchmark","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Thermal convection benchmark from  Blankenbach et al., 1989","category":"page"},{"location":"man/Blankenbach/#Initialize-packages","page":"Blankenbach","title":"Initialize packages","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Load JustRelax.jl necessary modules and define backend.","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"For this benchmark we will use particles to track the advection of the material phases and their information. For this, we will use JustPIC.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustPIC, JustPIC._2D\nconst backend = CPUBackend # Options: CPUBackend, CUDABackend, AMDGPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GeoParams","category":"page"},{"location":"man/Blankenbach/#Script","page":"Blankenbach","title":"Script","text":"","category":"section"},{"location":"man/Blankenbach/#Model-domain","page":"Blankenbach","title":"Model domain","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nx = ny      = 51                       # number of cells per dimension\nnit          = 6e3\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly * ar                  # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt = dt_diff = 0.9 * min(di...)^2 / 4.0 # diffusive CFL timestep limiter","category":"page"},{"location":"man/Blankenbach/#Rheology","page":"Blankenbach","title":"Rheology","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"rheology = (\n    SetMaterialParams(;\n        Phase             = 1,\n        Density           = PT_Density(; ρ0 = 1, α = 1, β = 0.0),\n        HeatCapacity      = ConstantHeatCapacity(; Cp = 1.0),\n        Conductivity      = ConstantConductivity(;  k = 1.0),\n        CompositeRheology = CompositeRheology((LinearViscous(; η = 1),)),\n        RadioactiveHeat   = ConstantRadioactiveHeat(0.0),\n        Gravity           = ConstantGravity(; g = 1e4),\n    ),\n)","category":"page"},{"location":"man/Blankenbach/#Initialize-particles","page":"Blankenbach","title":"Initialize particles","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nxcell              = 24 # initial number of perticles per cell\nmax_xcell           = 35 # maximum number of perticles per cell\nmin_xcell           = 12 # minimum number of perticles per cell\nparticles           = init_particles(\n    backend, nxcell, max_xcell, min_xcell, xvi..., di..., ni...\n) # particles object\nsubgrid_arrays      = SubgridDiffusionCellArrays(particles) # arrays needed for subgrid diffusion\n# velocity grids\ngrid_vx, grid_vy    = velocity_grids(xci, xvi, di) # staggered velocity grids","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we want to keep track of the temperature pT, temperature of the previous time step pT0, and material phase pPhase:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pT, pT0, pPhases = init_cell_arrays(particles, Val(3))\nparticle_args    = (pT, pT0, pPhases)","category":"page"},{"location":"man/Blankenbach/#Temperature-anomaly","page":"Blankenbach","title":"Temperature anomaly","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"xc_anomaly = 0.0     # origin of thermal anomaly\nyc_anomaly = 1 / 3   # origin of thermal anomaly\nr_anomaly  = 0.1 / 2 # radius of perturbation","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function init_phases!(phases, particles)\n    ni = size(phases)\n\n    @parallel_indices (i, j) function init_phases!(phases, index)\n        @inbounds for ip in JustRelax.cellaxes(phases)\n            # quick escape if the ip-th element of the [i,j]-th cell is empty\n            JustRelax.@cell(index[ip, i, j]) == 0 && continue\n            # all particles have phase number = 1.0\n            JustRelax.@cell phases[ip, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phases, particles.index)\nend\n\ninit_phases!(pPhases, particles, lx, yc_anomaly, r_anomaly)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or we can use the alternative one-liners","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@views pPhase.data[!isnan.(particles.index.data)] .= 1.0","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"map!(x -> isnan(x) ? NaN : 1.0, pPhase.data, particles.index.data)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/#Stokes-and-heat-diffusion-arrays","page":"Blankenbach","title":"Stokes and heat diffusion arrays","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Stokes arrays object","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the correspondent heat diffusion one","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"thermal = ThermalArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/#Initialize-thermal-profile-and-viscosity-fields","page":"Blankenbach","title":"Initialize thermal profile and viscosity fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"To initialize the thermal profile we use ParallelStencil.jl again","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@parallel_indices (i, j) function init_T!(T, y)\n    T[i, j] = 1 - y[j]\n    return nothing\nend\n\n@parallel (@idx size(thermal.T))  init_T!(thermal.T,  xvi[2]) # cell vertices\n@parallel (@idx size(thermal.Tc)) init_T!(thermal.Tc, xci[2]) # cell centers","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we define a rectangular thermal anomaly at x in 0 005, y in frac13 - 005 frac13 + 005","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function rectangular_perturbation!(T, xc, yc, r, xvi)\n    @parallel_indices (i, j) function _rectangular_perturbation!(T, xc, yc, r, x, y)\n        @inbounds if ((x[i]-xc)^2 ≤ r^2) && ((y[j] - yc)^2 ≤ r^2)\n            T[i, j] += .2\n        end\n        return nothing\n    end\n    ni = size(T)\n    @parallel (@idx ni) _rectangular_perturbation!(T, xc, yc, r, xvi...)\n    return nothing\nend\n\nxc_anomaly  = 0.0    # center of the thermal anomaly\nyc_anomaly  = 1/3    # center of the thermal anomaly\nr_anomaly   = 0.1/2  # half-width of the thermal anomaly\nrectangular_perturbation!(thermal.T, xc_anomaly, yc_anomaly, r_anomaly, xvi)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/Blankenbach/#Boundary-conditions","page":"Blankenbach","title":"Boundary conditions","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"flow_bcs      = VelocityBoundaryConditions(;\n    free_slip = (left = true, right=true, top=true, bot=true),\n)\nthermal_bc    = TemperatureBoundaryConditions(;\n    no_flux   = (left = true, right = true, top = false, bot = false),\n)\nthermal_bcs!(thermal, thermal_bc)\nthermal.Told .= thermal.T","category":"page"},{"location":"man/Blankenbach/#Pseuo-transient-coefficients","page":"Blankenbach","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)\npt_thermal  = PTThermalCoeffs(\n    backend_JR, rheology, phase_ratios, args, dt, ni, di, li; ϵ=1e-5, CFL = 1e-1 / √2.1\n)","category":"page"},{"location":"man/Blankenbach/#Just-before-solving-the-problem...","page":"Blankenbach","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We need to allocate some arrays to be able to do the subgrid diffusion of the temperature field at the particles level:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"T_buffer    = @zeros(ni.+1)     # without the ghost nodes at the x-direction\nTold_buffer = similar(T_buffer) # without the ghost nodes at the x-direction\ndt₀         = similar(stokes.P) # subgrid diffusion time scale\n# copy temperature to buffer arrays\nfor (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\n# interpolate temperatyre on the particles\ngrid2particle!(pT, xvi, T_buffer, particles)\npT0.data    .= pT.data","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function copyinn_x!(A, B)\n    @parallel function f_x(A, B)\n        @all(A) = @inn_x(B)\n        return nothing\n    end\n    @parallel f_x(A, B)\nend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"In this benchmark we want to keep track of the time trms, the rms-velocity Urms","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"U_rms = sqrtint_Omega (V_x^2 + V_y^2 ) dOmega","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the Nusselt number at the top of the model Nu_top","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Nu_top = int fracpartial Tpartial x dx","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And we will store their time history in the vectors:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Urms   = Float64[]\nNu_top = Float64[]\ntrms   = Float64[]","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We further need two buffer arrays where to interpolate the velocity field at the vertices of the grid cells","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Buffer arrays to compute velocity rms\nVx_v = @zeros(ni.+1...)\nVy_v = @zeros(ni.+1...)","category":"page"},{"location":"man/Blankenbach/#Advancing-one-time-step","page":"Blankenbach","title":"Advancing one time step","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Solve stokes","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    Inf,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)\n# calculate adaptive time step\ndt = compute_dt(stokes, di, dt_diff)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Heat diffusion solver","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"heatdiffusion_PT!(\n    thermal,\n    pt_thermal,\n    thermal_bc,\n    rheology,\n    args,\n    dt,\n    di;\n    kwargs = (;\n        igg     = igg,\n        phase   = phase_ratios,\n        iterMax = 10e3,\n        nout    = 1e2,\n        verbose = true,\n    )\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Subgrid diffusion at the particle level","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"for (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\nsubgrid_characteristic_time!(\n    subgrid_arrays, particles, dt₀, phase_ratios, rheology, thermal, stokes, xci, di\n)\ncentroid2particle!(subgrid_arrays.dt₀, xci, dt₀, particles)\nsubgrid_diffusion!(\n    pT, T_buffer, thermal.ΔT[2:end-1, :], subgrid_arrays, particles, xvi,  di, dt\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Advect particles","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# advect particles in space\nadvection!(particles, RungeKutta2(), @velocity(stokes), (grid_vx, grid_vy), dt)\n# advect particles in memory\nmove_particles!(particles, xvi, particle_args)\n# check if we need to inject particles\ninject_particles_phase!(particles, pPhases, (pT, ), (T_buffer, ), xvi)\n# update phase ratios\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Interpolate T back to the grid","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# interpolate fields from particle to grid vertices\nparticle2grid!(T_buffer, pT, xvi, particles)\n@views T_buffer[:, end]      .= 0.0\n@views T_buffer[:, 1]        .= 1.0\n@views thermal.T[2:end-1, :] .= T_buffer\nflow_bcs!(stokes, flow_bcs) # apply boundary conditions\ntemperature2center!(thermal)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Update buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"args = (; T = thermal.Tc, P = stokes.P,  dt=Inf)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Compute Nusselt number and rms-velocity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Nusselt number, Nu = ∫ ∂T/∂z dx\nNu_it = sum( ((abs.(thermal.T[2:end-1,end] - thermal.T[2:end-1,end-1])) ./ di[2]) .*di[1])\npush!(Nu_top, Nu_it)\n# Compute U rms\n# U₍ᵣₘₛ₎ = √ ∫∫ (vx²+vz²) dx dz\nUrms_it = let\n    JustRelax.JustRelax2D.velocity2vertex!(Vx_v, Vy_v, stokes.V.Vx, stokes.V.Vy; ghost_nodes=true)\n    @. Vx_v .= hypot.(Vx_v, Vy_v) # we reuse Vx_v to store the velocity magnitude\n    sqrt(sum( Vx_v.^2 .* prod(di)) )\nend\npush!(Urms, Urms_it)\npush!(trms, t)","category":"page"},{"location":"man/Blankenbach/#Visualization","page":"Blankenbach","title":"Visualization","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GLMakie","category":"page"},{"location":"man/Blankenbach/#Fields","page":"Blankenbach","title":"Fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Make particles plottable\np        = particles.coords\nppx, ppy = p\npxv      = ppx.data[:]\npyv      = ppy.data[:]\nclr      = pT.data[:]\nidxv     = particles.index.data[:];\n\n# Make Makie figure\nfig = Figure(size = (900, 900), title = \"t = $t\")\nax1 = Axis(fig[1,1], aspect = ar, title = \"T [K]  (t=$(t/(1e6 * 3600 * 24 *365.25)) Myrs)\")\nax2 = Axis(fig[2,1], aspect = ar, title = \"Vy [m/s]\")\nax3 = Axis(fig[1,3], aspect = ar, title = \"Vx [m/s]\")\nax4 = Axis(fig[2,3], aspect = ar, title = \"T [K]\")\n# grid temperature\nh1  = heatmap!(ax1, xvi[1], xvi[2], Array(thermal.T[2:end-1,:]) , colormap=:lajolla, colorrange=(0, 1) )\n# y-velocity\nh2  = heatmap!(ax2, xvi[1], xvi[2], Array(stokes.V.Vy) , colormap=:batlow)\n# x-velocity\nh3  = heatmap!(ax3, xvi[1], xvi[2], Array(stokes.V.Vx) , colormap=:batlow)\n# particles temperature\nh4  = scatter!(ax4, Array(pxv[idxv]), Array(pyv[idxv]), color=Array(clr[idxv]), colormap=:lajolla, colorrange=(0, 1), markersize=3)\nhidexdecorations!(ax1)\nhidexdecorations!(ax2)\nhidexdecorations!(ax3)\nColorbar(fig[1,2], h1)\nColorbar(fig[2,2], h2)\nColorbar(fig[1,4], h3)\nColorbar(fig[2,4], h4)\nlinkaxes!(ax1, ax2, ax3, ax4)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/Blankenbach/#Final-model","page":"Blankenbach","title":"Final model","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Temperature field (Image: Temperature)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And time history of the rms-velocity and Nusselt number (Image: time series)","category":"page"},{"location":"man/license/","page":"License","title":"License","text":"EditURL = \"https://github.com/PTsolvers/JustRelax.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"man/license/#license","page":"License","title":"License","text":"","category":"section"},{"location":"man/license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2021 Albert de Montserrat, Pascal Aellig and Authors (see Authors)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"man/advection/#Field-advection","page":"Advection","title":"Field advection","text":"","category":"section"},{"location":"man/advection/#Particles-in-Cell","page":"Advection","title":"Particles-in-Cell","text":"","category":"section"},{"location":"man/advection/","page":"Advection","title":"Advection","text":"JustRelax.jl relies on JustPIC.jl for advections of particles containing material information.","category":"page"},{"location":"man/advection/#Upwind","page":"Advection","title":"Upwind","text":"","category":"section"},{"location":"man/advection/#WENO5","page":"Advection","title":"WENO5","text":"","category":"section"},{"location":"man/material_physics/#Material-physics","page":"Material physics","title":"Material physics","text":"","category":"section"},{"location":"man/material_physics/","page":"Material physics","title":"Material physics","text":"JustRelax.jl is fully integrated with GeoParams.jl to perform all the material physics computations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = JustRelax","category":"page"},{"location":"#JustRelax.jl","page":"Home","title":"JustRelax.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Need to solve a very large multi-physics problem on many GPUs in parallel? Just Relax!","category":"page"},{"location":"","page":"Home","title":"Home","text":"JustRelax.jl is a collection of accelerated iterative pseudo-transient solvers using MPI and multiple CPU or GPU backends. It's part of the PTSolvers organisation and developed within the GPU4GEO project. Current publications, outreach and news can be found on the GPU4GEO website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package relies on other packages as building blocks and parallelisation tools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ParallelStencil.jl - device agnostic parallel kernels\nImplicitGlobalGrid.jl - (GPU-aware) distributed parallelisation (MPI)\nGeoParams.jl - Material physics\nJustPIC.jl - Particle-in-cell advection","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package serves several purposes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides a collection of solvers to be used in prototyping new applications\nIt provides some standardization so that application codes can\nmore easily handle local material properties through the use of GeoParams.jl\nmore easily switch between a pseudo-transient solver and another solvers (e.g. an explicit thermal solvers)\nIt provides a natural repository for contributions of new solvers for use by the larger community","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide several miniapps, each designed to solve a well-specified benchmark problem, in order to provide","category":"page"},{"location":"","page":"Home","title":"Home","text":"examples of usage in high-performance computing\nbasis on which to build more full-featured application codes\ncases for reference and performance tests","category":"page"}]
}
