var documenterSearchIndex = {"docs":
[{"location":"man/material_physics/#Material-physics","page":"Material physics","title":"Material physics","text":"","category":"section"},{"location":"man/material_physics/","page":"Material physics","title":"Material physics","text":"JustRelax is fully integrated with GeoParams.jl to perform all the material physics computations.","category":"page"},{"location":"man/ShearBands/#ShearBand-benchmark","page":"Shear Bands","title":"ShearBand benchmark","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Band benchmark to test the visco-elasto-plastic rheology implementation in JustRelax.jl","category":"page"},{"location":"man/ShearBands/#Initialize-packages","page":"Shear Bands","title":"Initialize packages","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Load JustRelax necessary modules and define backend.","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GeoParams","category":"page"},{"location":"man/ShearBands/#Script","page":"Shear Bands","title":"Script","text":"","category":"section"},{"location":"man/ShearBands/#Model-domain","page":"Shear Bands","title":"Model domain","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"nx = ny      = 64                       # number of cells per dimension\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly                       # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt           = Inf","category":"page"},{"location":"man/ShearBands/#Physical-properties-using-GeoParams","page":"Shear Bands","title":"Physical properties using GeoParams","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"τ_y     = 1.6           # yield stress. If do_DP=true, τ_y stand for the cohesion: c*cos(ϕ)\nϕ       = 30            # friction angle\nC       = τ_y           # Cohesion\nη0      = 1.0           # viscosity\nG0      = 1.0           # elastic shear modulus\nGi      = G0/(6.0-4.0)  # elastic shear modulus perturbation\nεbg     = 1.0           # background strain-rate\nη_reg   = 8e-3          # regularisation \"viscosity\"\ndt      = η0/G0/4.0     # assumes Maxwell time of 4\nel_bg   = ConstantElasticity(; G=G0, Kb=4)\nel_inc  = ConstantElasticity(; G=Gi, Kb=4)\nvisc    = LinearViscous(; η=η0)\npl      = DruckerPrager_regularised(;  # non-regularized plasticity\n    C    = C,\n    ϕ    = ϕ,\n    η_vp = η_reg,\n    Ψ    = 0\n)","category":"page"},{"location":"man/ShearBands/#Rheology","page":"Shear Bands","title":"Rheology","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    rheology = (\n        # Low density phase\n        SetMaterialParams(;\n            Phase             = 1,\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_bg, pl)),\n            Elasticity        = el_bg,\n\n        ),\n        # High density phase\n        SetMaterialParams(;\n            Density           = ConstantDensity(; ρ = 0.0),\n            Gravity           = ConstantGravity(; g = 0.0),\n            CompositeRheology = CompositeRheology((visc, el_inc, pl)),\n            Elasticity        = el_inc,\n        ),\n    )","category":"page"},{"location":"man/ShearBands/#Phase-anomaly","page":"Shear Bands","title":"Phase anomaly","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"function init_phases!(phase_ratios, xci, radius)\n    ni      = size(phase_ratios.center)\n    origin  = 0.5, 0.5\n\n    @parallel_indices (i, j) function init_phases!(phases, xc, yc, o_x, o_y, radius)\n        x, y = xc[i], yc[j]\n        if ((x-o_x)^2 + (y-o_y)^2) > radius^2\n            JustRelax.@cell phases[1, i, j] = 1.0\n            JustRelax.@cell phases[2, i, j] = 0.0\n\n        else\n            JustRelax.@cell phases[1, i, j] = 0.0\n            JustRelax.@cell phases[2, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phase_ratios.center, xci..., origin..., radius)\nend\n","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\ninit_phases!(phase_ratios, xci, radius)","category":"page"},{"location":"man/ShearBands/#Stokes-arrays","page":"Shear Bands","title":"Stokes arrays","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Stokes arrays object","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/ShearBands/#Initialize-viscosity-fields","page":"Shear Bands","title":"Initialize viscosity fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/ShearBands/#Boundary-conditions","page":"Shear Bands","title":"Boundary conditions","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    flow_bcs     = FlowBoundaryConditions(;\n        free_slip = (left = true, right = true, top = true, bot = true),\n        no_slip   = (left = false, right = false, top = false, bot=false),\n    )\n    stokes.V.Vx .= PTArray([ x*εbg for x in xvi[1], _ in 1:ny+2])\n    stokes.V.Vy .= PTArray([-y*εbg for _ in 1:nx+2, y in xvi[2]])\n    flow_bcs!(stokes, flow_bcs) # apply boundary conditions\n    update_halo!(stokes.V.Vx, stokes.V.Vy)\n","category":"page"},{"location":"man/ShearBands/#Pseuo-transient-coefficients","page":"Shear Bands","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)","category":"page"},{"location":"man/ShearBands/#Just-before-solving-the-problem...","page":"Shear Bands","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"In this benchmark we want to keep track of τII, the total time ttot, and the analytical elastic solution sol","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" solution(ε, t, G, η) = 2 * ε * η * (1 - exp(-G * t / η))","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"and store their time history in the vectors:","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"    τII        = Float64[]\n    sol        = Float64[]\n    ttot       = Float64[]","category":"page"},{"location":"man/ShearBands/#Advancing-one-time-step","page":"Shear Bands","title":"Advancing one time step","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Solve stokes","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    dt,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"calculate the second invariant and push to history vectors","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"tensor_invariant!(stokes.ε)\npush!(τII, maximum(stokes.τ.xx))\n\n\nit += 1\nt  += dt\n\npush!(sol, solution(εbg, t, G0, η0))\npush!(ttot, t)","category":"page"},{"location":"man/ShearBands/#Visualization","page":"Shear Bands","title":"Visualization","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"using GLMakie","category":"page"},{"location":"man/ShearBands/#Fields","page":"Shear Bands","title":"Fields","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":" # visualisation of high density inclusion\nth    = 0:pi/50:3*pi;\nxunit = @. radius * cos(th) + 0.5;\nyunit = @. radius * sin(th) + 0.5;\n\nfig   = Figure(size = (1600, 1600), title = \"t = $t\")\nax1   = Axis(fig[1,1], aspect = 1, title = L\"\\tau_{II}\", titlesize=35)\nax2   = Axis(fig[2,1], aspect = 1, title = L\"E_{II}\", titlesize=35)\nax3   = Axis(fig[1,2], aspect = 1, title = L\"\\log_{10}(\\varepsilon_{II})\", titlesize=35)\nax4   = Axis(fig[2,2], aspect = 1)\nheatmap!(ax1, xci..., Array(stokes.τ.II) , colormap=:batlow)\nheatmap!(ax2, xci..., Array(log10.(stokes.EII_pl)) , colormap=:batlow)\nheatmap!(ax3, xci..., Array(log10.(stokes.ε.II)) , colormap=:batlow)\nlines!(ax2, xunit, yunit, color = :black, linewidth = 5)\nlines!(ax4, ttot, τII, color = :black)\nlines!(ax4, ttot, sol, color = :red)\nhidexdecorations!(ax1)\nhidexdecorations!(ax3)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/ShearBands/#Final-model","page":"Shear Bands","title":"Final model","text":"","category":"section"},{"location":"man/ShearBands/","page":"Shear Bands","title":"Shear Bands","text":"Shear Bands evolution in a 2D visco-elasto-plastic rheology model (Image: Shearbands)","category":"page"},{"location":"man/Blankenbach/#Blankenbach-benchmark","page":"Blankenbach","title":"Blankenbach benchmark","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Thermal convection benchmark from  Blankenbach et al., 1989","category":"page"},{"location":"man/Blankenbach/#Initialize-packages","page":"Blankenbach","title":"Initialize packages","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Load JustRelax necessary modules and define backend.","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustRelax, JustRelax.JustRelax2D, JustRelax.DataIO\nconst backend_JR = CPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"For this benchmark we will use particles to track the advection of the material phases and their information. For this, we will use JustPIC.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using JustPIC, JustPIC._2D\nconst backend = CPUBackend # Options: CPUBackend, CUDABackend, AMDGPUBackend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will also use ParallelStencil.jl to write some device-agnostic helper functions:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2) #or (CUDA, Float64, 2) or (AMDGPU, Float64, 2)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and will use GeoParams.jl to define and compute physical properties of the materials:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GeoParams","category":"page"},{"location":"man/Blankenbach/#Script","page":"Blankenbach","title":"Script","text":"","category":"section"},{"location":"man/Blankenbach/#Model-domain","page":"Blankenbach","title":"Model domain","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nx = ny      = 51                       # number of cells per dimension\nnit          = 6e3\nigg          = IGG(\n    init_global_grid(nx, ny, 1; init_MPI= true)...\n)                                       # initialize MPI grid\nly           = 1.0                      # domain length in y\nlx           = ly * ar                  # domain length in x\nni           = nx, ny                   # number of cells\nli           = lx, ly                   # domain length in x- and y-\ndi           = @. li / ni               # grid step in x- and -y\norigin       = 0.0, 0.0                 # origin coordinates\ngrid         = Geometry(ni, li; origin = origin)\n(; xci, xvi) = grid                     # nodes at the center and vertices of the cells\ndt = dt_diff = 0.9 * min(di...)^2 / 4.0 # diffusive CFL timestep limiter","category":"page"},{"location":"man/Blankenbach/#Rheology","page":"Blankenbach","title":"Rheology","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"rheology = (\n    SetMaterialParams(;\n        Phase             = 1,\n        Density           = PT_Density(; ρ0 = 1, α = 1, β = 0.0),\n        HeatCapacity      = ConstantHeatCapacity(; Cp = 1.0),\n        Conductivity      = ConstantConductivity(;  k = 1.0),\n        CompositeRheology = CompositeRheology((LinearViscous(; η = 1),)),\n        RadioactiveHeat   = ConstantRadioactiveHeat(0.0),\n        Gravity           = ConstantGravity(; g = 1e4),\n    ),\n)","category":"page"},{"location":"man/Blankenbach/#Initialize-particles","page":"Blankenbach","title":"Initialize particles","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"nxcell              = 24 # initial number of perticles per cell\nmax_xcell           = 35 # maximum number of perticles per cell\nmin_xcell           = 12 # minimum number of perticles per cell\nparticles           = init_particles(\n    backend, nxcell, max_xcell, min_xcell, xvi..., di..., ni...\n) # particles object\nsubgrid_arrays      = SubgridDiffusionCellArrays(particles) # arrays needed for subgrid diffusion\n# velocity grids\ngrid_vx, grid_vy    = velocity_grids(xci, xvi, di) # staggered velocity grids","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we want to keep track of the temperature pT, temperature of the previous time step pT0, and material phase pPhase:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pT, pT0, pPhases = init_cell_arrays(particles, Val(3))\nparticle_args    = (pT, pT0, pPhases)","category":"page"},{"location":"man/Blankenbach/#Temperature-anomaly","page":"Blankenbach","title":"Temperature anomaly","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"xc_anomaly = 0.0     # origin of thermal anomaly\nyc_anomaly = 1 / 3   # origin of thermal anomaly\nr_anomaly  = 0.1 / 2 # radius of perturbation","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Helper function to initialize material phases with ParallelStencil.jl","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function init_phases!(phases, particles)\n    ni = size(phases)\n\n    @parallel_indices (i, j) function init_phases!(phases, index)\n        @inbounds for ip in JustRelax.cellaxes(phases)\n            # quick escape if the ip-th element of the [i,j]-th cell is empty\n            JustRelax.@cell(index[ip, i, j]) == 0 && continue\n            # all particles have phase number = 1.0\n            JustRelax.@cell phases[ip, i, j] = 1.0\n        end\n        return nothing\n    end\n\n    @parallel (@idx ni) init_phases!(phases, particles.index)\nend\n\ninit_phases!(pPhases, particles, lx, yc_anomaly, r_anomaly)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or we can use the alternative one-liners","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@views pPhase.data[!isnan.(particles.index.data)] .= 1.0","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"or","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"map!(x -> isnan(x) ? NaN : 1.0, pPhase.data, particles.index.data)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and finally we need the phase ratios at the cell centers:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"phase_ratios = PhaseRatio(backend_JR, ni, length(rheology))\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/#Stokes-and-heat-diffusion-arrays","page":"Blankenbach","title":"Stokes and heat diffusion arrays","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Stokes arrays object","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"stokes = StokesArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the correspondent heat diffusion one","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"thermal = ThermalArrays(backend_JR, ni)","category":"page"},{"location":"man/Blankenbach/#Initialize-thermal-profile-and-viscosity-fields","page":"Blankenbach","title":"Initialize thermal profile and viscosity fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"To initialize the thermal profile we use ParallelStencil.jl again","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"@parallel_indices (i, j) function init_T!(T, y)\n    T[i, j] = 1 - y[j]\n    return nothing\nend\n\n@parallel (@idx size(thermal.T))  init_T!(thermal.T,  xvi[2]) # cell vertices\n@parallel (@idx size(thermal.Tc)) init_T!(thermal.Tc, xci[2]) # cell centers","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and we define a rectangular thermal anomaly at x in 0 005, y in frac13 - 005 frac13 + 005","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function rectangular_perturbation!(T, xc, yc, r, xvi)\n    @parallel_indices (i, j) function _rectangular_perturbation!(T, xc, yc, r, x, y)\n        @inbounds if ((x[i]-xc)^2 ≤ r^2) && ((y[j] - yc)^2 ≤ r^2)\n            T[i, j] += .2\n        end\n        return nothing\n    end\n    ni = size(T)\n    @parallel (@idx ni) _rectangular_perturbation!(T, xc, yc, r, xvi...)\n    return nothing\nend\n\nxc_anomaly  = 0.0    # center of the thermal anomaly\nyc_anomaly  = 1/3    # center of the thermal anomaly\nr_anomaly   = 0.1/2  # half-width of the thermal anomaly\nrectangular_perturbation!(thermal.T, xc_anomaly, yc_anomaly, r_anomaly, xvi)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We initialize the buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"ρg               = @zeros(ni...), @zeros(ni...)\nη                = @ones(ni...)\nargs             = (; T = thermal.Tc, P = stokes.P, dt = Inf)\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where (-Inf, Inf) is the viscosity cutoff.","category":"page"},{"location":"man/Blankenbach/#Boundary-conditions","page":"Blankenbach","title":"Boundary conditions","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"flow_bcs      = FlowBoundaryConditions(;\n    free_slip = (left = true, right=true, top=true, bot=true),\n)\nthermal_bc    = TemperatureBoundaryConditions(;\n    no_flux   = (left = true, right = true, top = false, bot = false),\n)\nthermal_bcs!(thermal, thermal_bc)\nthermal.Told .= thermal.T","category":"page"},{"location":"man/Blankenbach/#Pseuo-transient-coefficients","page":"Blankenbach","title":"Pseuo-transient coefficients","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"pt_stokes   = PTStokesCoeffs(li, di; ϵ=1e-4,  CFL = 1 / √2.1)\npt_thermal  = PTThermalCoeffs(\n    backend_JR, rheology, phase_ratios, args, dt, ni, di, li; ϵ=1e-5, CFL = 1e-1 / √2.1\n)","category":"page"},{"location":"man/Blankenbach/#Just-before-solving-the-problem...","page":"Blankenbach","title":"Just before solving the problem...","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We need to allocate some arrays to be able to do the subgrid diffusion of the temperature field at the particles level:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"T_buffer    = @zeros(ni.+1)     # without the ghost nodes at the x-direction\nTold_buffer = similar(T_buffer) # without the ghost nodes at the x-direction\ndt₀         = similar(stokes.P) # subgrid diffusion time scale\n# copy temperature to buffer arrays\nfor (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\n# interpolate temperatyre on the particles\ngrid2particle!(pT, xvi, T_buffer, particles)\npT0.data    .= pT.data","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"where","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"function copyinn_x!(A, B)\n    @parallel function f_x(A, B)\n        @all(A) = @inn_x(B)\n        return nothing\n    end\n    @parallel f_x(A, B)\nend","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"In this benchmark we want to keep track of the time trms, the rms-velocity Urms","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"$","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"U{rms} = \\sqrt{ \\int{\\Omega} (Vx^2 + Vy^2 ) d\\Omega} $","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"and the Nusselt number at the top of the model Nu_top","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"$","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Nu_{top} = \\int \\frac{\\partial T}{\\partial x} dx $","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And we will store their time history in the vectors:","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Urms   = Float64[]\nNu_top = Float64[]\ntrms   = Float64[]","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We further need two buffer arrays where to interpolate the velocity field at the vertices of the grid cells","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Buffer arrays to compute velocity rms\nVx_v = @zeros(ni.+1...)\nVy_v = @zeros(ni.+1...)","category":"page"},{"location":"man/Blankenbach/#Advancing-one-time-step","page":"Blankenbach","title":"Advancing one time step","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Solve stokes","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"solve!(\n    stokes,\n    pt_stokes,\n    di,\n    flow_bcs,\n    ρg,\n    phase_ratios,\n    rheology,\n    args,\n    Inf,\n    igg;\n    kwargs = (;\n        iterMax          = 150e3,\n        nout             = 200,\n        viscosity_cutoff = (-Inf, Inf),\n        verbose          = true\n    )\n)\n# calculate adaptive time step\ndt = compute_dt(stokes, di, dt_diff)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Heat diffusion solver","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"heatdiffusion_PT!(\n    thermal,\n    pt_thermal,\n    thermal_bc,\n    rheology,\n    args,\n    dt,\n    di;\n    kwargs = (;\n        igg     = igg,\n        phase   = phase_ratios,\n        iterMax = 10e3,\n        nout    = 1e2,\n        verbose = true,\n    )\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Subgrid diffusion at the particle level","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"for (dst, src) in zip((T_buffer, Told_buffer), (thermal.T, thermal.Told))\n    copyinn_x!(dst, src)\nend\nsubgrid_characteristic_time!(\n    subgrid_arrays, particles, dt₀, phase_ratios, rheology, thermal, stokes, xci, di\n)\ncentroid2particle!(subgrid_arrays.dt₀, xci, dt₀, particles)\nsubgrid_diffusion!(\n    pT, T_buffer, thermal.ΔT[2:end-1, :], subgrid_arrays, particles, xvi,  di, dt\n)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Advect particles","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# advect particles in space\nadvection!(particles, RungeKutta2(), @velocity(stokes), (grid_vx, grid_vy), dt)\n# advect particles in memory\nmove_particles!(particles, xvi, particle_args)\n# check if we need to inject particles\ninject_particles_phase!(particles, pPhases, (pT, ), (T_buffer, ), xvi)\n# update phase ratios\nphase_ratios_center(phase_ratios, particles, grid, pPhases)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Interpolate T back to the grid","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# interpolate fields from particle to grid vertices\nparticle2grid!(T_buffer, pT, xvi, particles)\n@views T_buffer[:, end]      .= 0.0\n@views T_buffer[:, 1]        .= 1.0\n@views thermal.T[2:end-1, :] .= T_buffer\nflow_bcs!(stokes, flow_bcs) # apply boundary conditions\ntemperature2center!(thermal)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Update buoyancy forces and viscosity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"args = (; T = thermal.Tc, P = stokes.P,  dt=Inf)\ncompute_viscosity!(stokes, 1.0, phase_ratios, args, rheology, (-Inf, Inf))\ncompute_ρg!(ρg[2], phase_ratios, rheology, args)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Compute Nusselt number and rms-velocity","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Nusselt number, Nu = ∫ ∂T/∂z dx\nNu_it = sum( ((abs.(thermal.T[2:end-1,end] - thermal.T[2:end-1,end-1])) ./ di[2]) .*di[1])\npush!(Nu_top, Nu_it)\n# Compute U rms\n# U₍ᵣₘₛ₎ = √ ∫∫ (vx²+vz²) dx dz\nUrms_it = let\n    JustRelax.JustRelax2D.velocity2vertex!(Vx_v, Vy_v, stokes.V.Vx, stokes.V.Vy; ghost_nodes=true)\n    @. Vx_v .= hypot.(Vx_v, Vy_v) # we reuse Vx_v to store the velocity magnitude\n    sqrt(sum( Vx_v.^2 .* prod(di)) )\nend\npush!(Urms, Urms_it)\npush!(trms, t)","category":"page"},{"location":"man/Blankenbach/#Visualization","page":"Blankenbach","title":"Visualization","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"We will use Makie.jl to visualize the results","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"using GLMakie","category":"page"},{"location":"man/Blankenbach/#Fields","page":"Blankenbach","title":"Fields","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"# Make particles plottable\np        = particles.coords\nppx, ppy = p\npxv      = ppx.data[:]\npyv      = ppy.data[:]\nclr      = pT.data[:]\nidxv     = particles.index.data[:];\n\n# Make Makie figure\nfig = Figure(size = (900, 900), title = \"t = $t\")\nax1 = Axis(fig[1,1], aspect = ar, title = \"T [K]  (t=$(t/(1e6 * 3600 * 24 *365.25)) Myrs)\")\nax2 = Axis(fig[2,1], aspect = ar, title = \"Vy [m/s]\")\nax3 = Axis(fig[1,3], aspect = ar, title = \"Vx [m/s]\")\nax4 = Axis(fig[2,3], aspect = ar, title = \"T [K]\")\n# grid temperature\nh1  = heatmap!(ax1, xvi[1], xvi[2], Array(thermal.T[2:end-1,:]) , colormap=:lajolla, colorrange=(0, 1) )\n# y-velocity\nh2  = heatmap!(ax2, xvi[1], xvi[2], Array(stokes.V.Vy) , colormap=:batlow)\n# x-velocity\nh3  = heatmap!(ax3, xvi[1], xvi[2], Array(stokes.V.Vx) , colormap=:batlow)\n# particles temperature\nh4  = scatter!(ax4, Array(pxv[idxv]), Array(pyv[idxv]), color=Array(clr[idxv]), colormap=:lajolla, colorrange=(0, 1), markersize=3)\nhidexdecorations!(ax1)\nhidexdecorations!(ax2)\nhidexdecorations!(ax3)\nColorbar(fig[1,2], h1)\nColorbar(fig[2,2], h2)\nColorbar(fig[1,4], h3)\nColorbar(fig[2,4], h4)\nlinkaxes!(ax1, ax2, ax3, ax4)\nsave(joinpath(figdir, \"$(it).png\"), fig)\nfig","category":"page"},{"location":"man/Blankenbach/#Final-model","page":"Blankenbach","title":"Final model","text":"","category":"section"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"Temperature field (Image: Temperature)","category":"page"},{"location":"man/Blankenbach/","page":"Blankenbach","title":"Blankenbach","text":"And time history of the rms-velocity and Nusselt number (Image: time series)","category":"page"},{"location":"man/advection/#Field-advection","page":"Advection","title":"Field advection","text":"","category":"section"},{"location":"man/advection/#Particles-in-Cell","page":"Advection","title":"Particles-in-Cell","text":"","category":"section"},{"location":"man/advection/","page":"Advection","title":"Advection","text":"JustRelax relies on JustPIC.jl for advections of particles containing material information.","category":"page"},{"location":"man/advection/#Upwind","page":"Advection","title":"Upwind","text":"","category":"section"},{"location":"man/advection/#WENO5","page":"Advection","title":"WENO5","text":"","category":"section"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here an overview of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [JustRelax, JustRelax.JustRelax2D, JustRelax.JustRelax3D, JustRelax.DataIO]","category":"page"},{"location":"man/listfunctions/#JustRelax.Geometry","page":"List of functions","title":"JustRelax.Geometry","text":"struct Geometry{nDim,T}\n\nA struct representing the geometry of a topological object in nDim dimensions.\n\nArguments\n\nnDim: The number of dimensions of the topological object.\nT: The type of the elements in the topological object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.cart2ind-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{Int64, N1}}, Vararg{Int64, N2}}} where {N1, N2}","page":"List of functions","title":"JustRelax.cart2ind","text":"cart2ind(A)\n\nReturn the linear index of a n-dimensional array corresponding to the cartesian indices I\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.element-Union{Tuple{D}, Tuple{Nc}, Tuple{N}, Tuple{T_elem}, Tuple{CellArrays.CellArray{StaticArraysCore.SVector, N, D, T_elem}, Int64, Vararg{Int64, Nc}}} where {T_elem, N, Nc, D}","page":"List of functions","title":"JustRelax.element","text":"element(A, element_indices..., cell_indices...)\n\nReturn a the element with element_indices of the Cell with cell_indices of the CellArray A.\n\nArguments\n\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.setelement!-Union{Tuple{D}, Tuple{T_elem}, Tuple{N}, Tuple{T}, Tuple{N_array}, Tuple{Nj}, Tuple{Ni}, Tuple{Nc}, Tuple{CellArrays.CellArray{StaticArraysCore.SMatrix{Ni, Nj, T, N_array}, N, D, T_elem}, T, Any, Any, Vararg{Int64, Nc}}} where {Nc, Ni, Nj, N_array, T, N, T_elem, D}","page":"List of functions","title":"JustRelax.setelement!","text":"setelement!(A, x, element_indices..., cell_indices...)\n\nStore the given value x at the given element with element_indices of the cell with the indices cell_indices\n\nArguments\n\nx::Number: value to be stored in the index element_indices of the cell with cell_indices.\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.velocity_grids-Union{Tuple{T}, Tuple{Any, Any, Tuple{T, T}}} where T","page":"List of functions","title":"JustRelax.velocity_grids","text":"velocity_grids(xci, xvi, di::NTuple{N,T}) where {N,T}\n\nCompute the velocity grids for N dimensionional problems.\n\nArguments\n\nxci: The x-coordinate of the cell centers.\nxvi: The x-coordinate of the cell vertices.\ndi: A tuple containing the cell dimensions.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.WENO5","page":"List of functions","title":"JustRelax.JustRelax2D.WENO5","text":"WENO5{T, N, A, M} <: AbstractWENO\n\nThe WENO5 is a structure representing the Weighted Essentially Non-Oscillatory (WENO) scheme of order 5 for the solution of hyperbolic partial differential equations.\n\nFields\n\nd0L, d1L, d2L: Upwind constants.\nd0R, d1R, d2R: Downwind constants.\nc1, c2: Constants for betas.\nsc1, sc2, sc3, sc4, sc5: Stencil weights.\nϵ: Tolerance.\nni: Grid size.\nut: Intermediate buffer array.\nfL, fR, fB, fT: Fluxes.\nmethod: Method (1:JS, 2:Z).\n\nDescription\n\nThe WENO5 structure contains the parameters and temporary variables used in the WENO scheme. These include the upwind and downwind constants, the constants for betas, the stencil candidate weights, the tolerance, the grid size, the fluxes, and the method.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.WENO_advection!-NTuple{5, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.WENO_advection!","text":"WENO_advection!(u, Vxi, weno, di, ni, dt)\n\nPerform the advection step of the Weighted Essentially Non-Oscillatory (WENO) scheme for the solution of hyperbolic partial differential equations.\n\nArguments\n\nu: field to be advected.\nVxi: velocity field.\nweno: structure containing the WENO scheme parameters and temporary variables.\ndi: grid spacing.\nni: number of grid points.\ndt: time step.\n\nDescription\n\nThe function first calculates the fluxes using the WENO scheme. Then it performs three steps of the WENO scheme. Each step involves calculating the right-hand side of the WENO equation and updating the solution u. The updating of the solution u is done using different combinations of the original solution and the temporary solution weno.ut.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._compute_dt-Tuple{JustRelax.StokesArrays, Any, Any, IGG}","page":"List of functions","title":"JustRelax.JustRelax2D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, dt_diff)\n\nCompute the time step dt for the velocity field S.V and the diffusive maximum time step dt_diff for a regular gridwith grid spacing di. The implicit global grid variable I implies that the time step is calculated globally and not separately on each block.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._compute_dt-Tuple{JustRelax.StokesArrays, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, dt_diff)\n\nCompute the time step dt for the velocity field S.V and the diffusive maximum time step dt_diff for a regular gridwith grid spacing di.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._compute_dt-Tuple{JustRelax.StokesArrays, Any, IGG}","page":"List of functions","title":"JustRelax.JustRelax2D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, igg)\n\nCompute the time step dt for the velocity field S.V for a regular gridwith grid spacing di. The implicit global grid variable I implies that the time step is calculated globally and not separately on each block.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._compute_dt-Tuple{JustRelax.StokesArrays, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di)\n\nCompute the time step dt for the velocity field S.V for a regular grid with grid spacing di.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, AbstractArray, AbstractArray, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, K, ρCp, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations. Both K and ρCp are n-dimensional arrays.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, Any, NamedTuple, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, rheology, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.allzero-Union{Tuple{Vararg{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax2D.allzero","text":"allzero(x::Vararg{T,N}) where {T,N}\n\nCheck if all elements in x are zero.\n\nArguments\n\nx::Vararg{T,N}: The input array.\n\nReturns\n\nBool: true if all elements in x are zero, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.assign!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax2D.assign!","text":"assign!(B::AbstractArray{T,N}, A::AbstractArray{T,N}) where {T,N}\n\nAssigns the values of array A to array B in parallel.\n\nArguments\n\nB::AbstractArray{T,N}: The destination array.\nA::AbstractArray{T,N}: The source array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_P!-Union{Tuple{N}, Tuple{Any, Any, Any, Any, Any, Tuple{Vararg{GeoParams.MaterialParameters.MaterialParams, N}}, Any, Any, Any, Any, NamedTuple}} where N","page":"List of functions","title":"JustRelax.JustRelax2D.compute_P!","text":"computeP!(P, P0, RP, ∇V, ΔTc, η, rheology::NTuple{N,MaterialParams}, phaseratio::C, dt, r, θ_dτ)\n\nCompute the pressure field P and the residual RP for the compressible case. This function introduces thermal stresses after the implementation of Kiss et al. (2023). The temperature difference ΔTc on the cell center is used to compute this as well as α as the thermal expansivity.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology, args, phase_ratios)\n\nCompute the buoyancy forces based on the given rheology, arguments, and phase ratios.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required by the rheology.\nphase_ratios: The ratios of the different phases.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology, args)\n\nCompute the buoyancy forces based on the given rheology and arguments.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args, phase_ratios)\n\nCompute the buoyancy forces for a given set of material parameters, arguments, and phase ratios.\n\nArguments\n\nrheology: The material parameters.\nargs: The arguments.\nphase_ratios: The phase ratios.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args)\n\nCompute the buoyancy forces based on the given rheology parameters and arguments.\n\nArguments\n\nrheology::MaterialParams: The material parameters for the rheology.\nargs: The arguments for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_maxloc!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_maxloc!","text":"maxloc!(B, A; window)\n\nCompute the maximum value of A in the window = (width_x, width_y, width_z) and store the result in B.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_ρg!-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_ρg!","text":"compute_ρg!(ρg, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.compute_ρg!-Tuple{Any, JustRelax.PhaseRatio, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.compute_ρg!","text":"compute_ρg!(ρg, phase_ratios, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.  The phase_ratios are used to compute the density of the composite rheology.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.continuation_log-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"List of functions","title":"JustRelax.JustRelax2D.continuation_log","text":"continuation_log(x_new, x_old, ν)\n\nDo a continuation step exp((1-ν)*log(x_old) + ν*log(x_new)) with damping parameter ν\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.flow_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.flow_bcs!","text":"flow_bcs!(stokes, bcs::FlowBoundaryConditions, di)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.fn_ratio-Union{Tuple{F}, Tuple{N}, Tuple{F, Tuple{Vararg{GeoParams.AbstractMaterialParamsStruct, N}}, Any}} where {N, F}","page":"List of functions","title":"JustRelax.JustRelax2D.fn_ratio","text":"fn_ratio(fn::F, rheology::NTuple{N, AbstractMaterialParamsStruct}, ratio) where {N, F}\n\nAverage the function fn over the material phases in rheology using the phase ratios ratio.    \n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.interp_Vx_on_Vy!-Tuple{Any, Any, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}","page":"List of functions","title":"JustRelax.JustRelax2D.interp_Vx_on_Vy!","text":"interp_Vx_on_Vy!(Vx_on_Vy, Vx)\n\nInterpolates the values of Vx onto the grid points of Vy.\n\nArguments\n\nVx_on_Vy::AbstractArray: Vx at Vy grid points.\nVx::AbstractArray: Vx at its staggered grid points.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.nphases-Tuple{JustRelax.PhaseRatio}","page":"List of functions","title":"JustRelax.JustRelax2D.nphases","text":"nphases(x::JustRelax.PhaseRatio)\n\nReturn the number of phases in x::JustRelax.PhaseRatio.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.rotate_stress!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Any, Any}} where {N, T}","page":"List of functions","title":"JustRelax.JustRelax2D.rotate_stress!","text":"Jaumann derivative\n\nτijo += vk * ∂τijo/∂xk - ωij * ∂τkjo + ∂τkjo * ωij\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.take-Tuple{String}","page":"List of functions","title":"JustRelax.JustRelax2D.take","text":"take(fldr::String)\n\nCreate folder fldr if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.tensor_invariant!-Tuple{JustRelax.SymmetricTensor}","page":"List of functions","title":"JustRelax.JustRelax2D.tensor_invariant!","text":"tensor_invariant!(A::JustRelax.SymmetricTensor)\n\nCompute the tensor invariant of the given symmetric tensor A.\n\nArguments\n\nA::JustRelax.SymmetricTensor: The input symmetric tensor.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.thermal_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.thermal_bcs!","text":"thermal_bcs!(T, bcs::TemperatureBoundaryConditions)\n\nApply the prescribed heat boundary conditions bc on the T\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.velocity2vertex!-NTuple{6, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.velocity2vertex!","text":"velocity2vertex!(Vx_v, Vy_v, Vz_v, Vx, Vy, Vz)\n\nIn-place interpolation of the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the pre-allocated Vx_d, Vy_d, Vz_d 3D arrays located at the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.velocity2vertex-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.velocity2vertex","text":"velocity2vertex(Vx, Vy, Vz)\n\nInterpolate the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@add-Tuple{Any, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax2D.@add","text":"@add(I, args...)\n\nAdd I to the scalars in args\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@copy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@copy","text":"copy(B, A)\n\nconvenience macro to copy data from the array A into array B\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@idx-Tuple","page":"List of functions","title":"JustRelax.JustRelax2D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@normal-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@normal","text":"@normal(A)\n\nUnpacks the normal components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@qT-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@qT","text":"@qT(V)\n\nUnpacks the flux arrays qT_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@qT2-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@qT2","text":"@qT2(V)\n\nUnpacks the flux arrays qT2_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@residuals-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@residuals","text":"@residuals(A)\n\nUnpacks the momentum residuals from A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@shear-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@shear","text":"@shear(A)\n\nUnpacks the shear components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@strain","text":"@strain(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@strain_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@strain_center","text":"@strain_center(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@strain_plastic-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@strain_plastic","text":"@strain_plastic(A)\n\nUnpacks the plastic strain rate tensor ε_pl from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@stress-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@stress","text":"@stress(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@stress_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@stress_center","text":"@stress_center(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@tensor-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@tensor","text":"@tensor(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@tensor_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@tensor_center","text":"@tensor_center(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax2D.@velocity-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax2D.@velocity","text":"@velocity(V)\n\nUnpacks the velocity arrays V from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.WENO5","page":"List of functions","title":"JustRelax.JustRelax3D.WENO5","text":"WENO5{T, N, A, M} <: AbstractWENO\n\nThe WENO5 is a structure representing the Weighted Essentially Non-Oscillatory (WENO) scheme of order 5 for the solution of hyperbolic partial differential equations.\n\nFields\n\nd0L, d1L, d2L: Upwind constants.\nd0R, d1R, d2R: Downwind constants.\nc1, c2: Constants for betas.\nsc1, sc2, sc3, sc4, sc5: Stencil weights.\nϵ: Tolerance.\nni: Grid size.\nut: Intermediate buffer array.\nfL, fR, fB, fT: Fluxes.\nmethod: Method (1:JS, 2:Z).\n\nDescription\n\nThe WENO5 structure contains the parameters and temporary variables used in the WENO scheme. These include the upwind and downwind constants, the constants for betas, the stencil candidate weights, the tolerance, the grid size, the fluxes, and the method.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.WENO_advection!-NTuple{5, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.WENO_advection!","text":"WENO_advection!(u, Vxi, weno, di, ni, dt)\n\nPerform the advection step of the Weighted Essentially Non-Oscillatory (WENO) scheme for the solution of hyperbolic partial differential equations.\n\nArguments\n\nu: field to be advected.\nVxi: velocity field.\nweno: structure containing the WENO scheme parameters and temporary variables.\ndi: grid spacing.\nni: number of grid points.\ndt: time step.\n\nDescription\n\nThe function first calculates the fluxes using the WENO scheme. Then it performs three steps of the WENO scheme. Each step involves calculating the right-hand side of the WENO equation and updating the solution u. The updating of the solution u is done using different combinations of the original solution and the temporary solution weno.ut.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._compute_dt-Tuple{JustRelax.StokesArrays, Any, Any, IGG}","page":"List of functions","title":"JustRelax.JustRelax3D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, dt_diff)\n\nCompute the time step dt for the velocity field S.V and the diffusive maximum time step dt_diff for a regular gridwith grid spacing di. The implicit global grid variable I implies that the time step is calculated globally and not separately on each block.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._compute_dt-Tuple{JustRelax.StokesArrays, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, dt_diff)\n\nCompute the time step dt for the velocity field S.V and the diffusive maximum time step dt_diff for a regular gridwith grid spacing di.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._compute_dt-Tuple{JustRelax.StokesArrays, Any, IGG}","page":"List of functions","title":"JustRelax.JustRelax3D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di, igg)\n\nCompute the time step dt for the velocity field S.V for a regular gridwith grid spacing di. The implicit global grid variable I implies that the time step is calculated globally and not separately on each block.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._compute_dt-Tuple{JustRelax.StokesArrays, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._compute_dt","text":"compute_dt(S::JustRelax.StokesArrays, di)\n\nCompute the time step dt for the velocity field S.V for a regular grid with grid spacing di.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, AbstractArray, AbstractArray, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, K, ρCp, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations. Both K and ρCp are n-dimensional arrays.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D._heatdiffusion_PT!-Tuple{JustRelax.ThermalArrays, JustRelax.PTThermalCoeffs, TemperatureBoundaryConditions, Any, NamedTuple, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D._heatdiffusion_PT!","text":"heatdiffusion_PT!(thermal, pt_thermal, rheology, dt, di; iterMax, nout, verbose)\n\nHeat diffusion solver using Pseudo-Transient iterations.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.allzero-Union{Tuple{Vararg{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax3D.allzero","text":"allzero(x::Vararg{T,N}) where {T,N}\n\nCheck if all elements in x are zero.\n\nArguments\n\nx::Vararg{T,N}: The input array.\n\nReturns\n\nBool: true if all elements in x are zero, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.assign!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}} where {T, N}","page":"List of functions","title":"JustRelax.JustRelax3D.assign!","text":"assign!(B::AbstractArray{T,N}, A::AbstractArray{T,N}) where {T,N}\n\nAssigns the values of array A to array B in parallel.\n\nArguments\n\nB::AbstractArray{T,N}: The destination array.\nA::AbstractArray{T,N}: The source array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_P!-Union{Tuple{N}, Tuple{Any, Any, Any, Any, Any, Tuple{Vararg{GeoParams.MaterialParameters.MaterialParams, N}}, Any, Any, Any, Any, NamedTuple}} where N","page":"List of functions","title":"JustRelax.JustRelax3D.compute_P!","text":"computeP!(P, P0, RP, ∇V, ΔTc, η, rheology::NTuple{N,MaterialParams}, phaseratio::C, dt, r, θ_dτ)\n\nCompute the pressure field P and the residual RP for the compressible case. This function introduces thermal stresses after the implementation of Kiss et al. (2023). The temperature difference ΔTc on the cell center is used to compute this as well as α as the thermal expansivity.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology, args, phase_ratios)\n\nCompute the buoyancy forces based on the given rheology, arguments, and phase ratios.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required by the rheology.\nphase_ratios: The ratios of the different phases.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology, args)\n\nCompute the buoyancy forces based on the given rheology and arguments.\n\nArguments\n\nrheology: The rheology used to compute the buoyancy forces.\nargs: Additional arguments required for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args, phase_ratios)\n\nCompute the buoyancy forces for a given set of material parameters, arguments, and phase ratios.\n\nArguments\n\nrheology: The material parameters.\nargs: The arguments.\nphase_ratios: The phase ratios.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_buoyancy-Tuple{GeoParams.MaterialParameters.MaterialParams, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_buoyancy","text":"compute_buoyancy(rheology::MaterialParams, args)\n\nCompute the buoyancy forces based on the given rheology parameters and arguments.\n\nArguments\n\nrheology::MaterialParams: The material parameters for the rheology.\nargs: The arguments for the computation.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_maxloc!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_maxloc!","text":"maxloc!(B, A; window)\n\nCompute the maximum value of A in the window = (width_x, width_y, width_z) and store the result in B.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_ρg!-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_ρg!","text":"compute_ρg!(ρg, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.compute_ρg!-Tuple{Any, JustRelax.PhaseRatio, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.compute_ρg!","text":"compute_ρg!(ρg, phase_ratios, rheology, args)\n\nCalculate the buoyance forces ρg for the given GeoParams.jl rheology object and correspondent arguments args.  The phase_ratios are used to compute the density of the composite rheology.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.continuation_log-Union{Tuple{T}, Tuple{T, T, Any}} where T","page":"List of functions","title":"JustRelax.JustRelax3D.continuation_log","text":"continuation_log(x_new, x_old, ν)\n\nDo a continuation step exp((1-ν)*log(x_old) + ν*log(x_new)) with damping parameter ν\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.flow_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.flow_bcs!","text":"flow_bcs!(stokes, bcs::FlowBoundaryConditions, di)\n\nApply the prescribed flow boundary conditions bc on the stokes\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.fn_ratio-Union{Tuple{F}, Tuple{N}, Tuple{F, Tuple{Vararg{GeoParams.AbstractMaterialParamsStruct, N}}, Any}} where {N, F}","page":"List of functions","title":"JustRelax.JustRelax3D.fn_ratio","text":"fn_ratio(fn::F, rheology::NTuple{N, AbstractMaterialParamsStruct}, ratio) where {N, F}\n\nAverage the function fn over the material phases in rheology using the phase ratios ratio.    \n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.interp_Vx_on_Vy!-Tuple{Any, Any, Tuple{UnitRange, UnitRange, UnitRange}, Int64, Int64, Int64}","page":"List of functions","title":"JustRelax.JustRelax3D.interp_Vx_on_Vy!","text":"interp_Vx_on_Vy!(Vx_on_Vy, Vx)\n\nInterpolates the values of Vx onto the grid points of Vy.\n\nArguments\n\nVx_on_Vy::AbstractArray: Vx at Vy grid points.\nVx::AbstractArray: Vx at its staggered grid points.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.nphases-Tuple{JustRelax.PhaseRatio}","page":"List of functions","title":"JustRelax.JustRelax3D.nphases","text":"nphases(x::JustRelax.PhaseRatio)\n\nReturn the number of phases in x::JustRelax.PhaseRatio.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.rotate_stress!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Any, Any}} where {N, T}","page":"List of functions","title":"JustRelax.JustRelax3D.rotate_stress!","text":"Jaumann derivative\n\nτijo += vk * ∂τijo/∂xk - ωij * ∂τkjo + ∂τkjo * ωij\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.take-Tuple{String}","page":"List of functions","title":"JustRelax.JustRelax3D.take","text":"take(fldr::String)\n\nCreate folder fldr if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.tensor_invariant!-Tuple{JustRelax.SymmetricTensor}","page":"List of functions","title":"JustRelax.JustRelax3D.tensor_invariant!","text":"tensor_invariant!(A::JustRelax.SymmetricTensor)\n\nCompute the tensor invariant of the given symmetric tensor A.\n\nArguments\n\nA::JustRelax.SymmetricTensor: The input symmetric tensor.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.thermal_bcs!-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.thermal_bcs!","text":"thermal_bcs!(T, bcs::TemperatureBoundaryConditions)\n\nApply the prescribed heat boundary conditions bc on the T\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.velocity2vertex!-NTuple{6, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.velocity2vertex!","text":"velocity2vertex!(Vx_v, Vy_v, Vz_v, Vx, Vy, Vz)\n\nIn-place interpolation of the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the pre-allocated Vx_d, Vy_d, Vz_d 3D arrays located at the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.velocity2vertex-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.velocity2vertex","text":"velocity2vertex(Vx, Vy, Vz)\n\nInterpolate the velocity field Vx, Vy, Vz from a staggered grid with ghost nodes  onto the grid vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@add-Tuple{Any, Vararg{Any}}","page":"List of functions","title":"JustRelax.JustRelax3D.@add","text":"@add(I, args...)\n\nAdd I to the scalars in args\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@copy-Tuple{Any, Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@copy","text":"copy(B, A)\n\nconvenience macro to copy data from the array A into array B\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@idx-Tuple","page":"List of functions","title":"JustRelax.JustRelax3D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@normal-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@normal","text":"@normal(A)\n\nUnpacks the normal components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@qT-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@qT","text":"@qT(V)\n\nUnpacks the flux arrays qT_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@qT2-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@qT2","text":"@qT2(V)\n\nUnpacks the flux arrays qT2_i from the ThermalArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@residuals-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@residuals","text":"@residuals(A)\n\nUnpacks the momentum residuals from A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@shear-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@shear","text":"@shear(A)\n\nUnpacks the shear components of the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@strain-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@strain","text":"@strain(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@strain_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@strain_center","text":"@strain_center(A)\n\nUnpacks the strain rate tensor ε from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@strain_plastic-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@strain_plastic","text":"@strain_plastic(A)\n\nUnpacks the plastic strain rate tensor ε_pl from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@stress-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@stress","text":"@stress(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@stress_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@stress_center","text":"@stress_center(A)\n\nUnpacks the deviatoric stress tensor τ from the StokesArrays A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@tensor-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@tensor","text":"@tensor(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the staggered grid. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@tensor_center-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@tensor_center","text":"@tensor_center(A)\n\nUnpacks the symmetric tensor A, where its components are defined in the center of the grid cells. Shear components are unpack following Voigt's notation.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.JustRelax3D.@velocity-Tuple{Any}","page":"List of functions","title":"JustRelax.JustRelax3D.@velocity","text":"@velocity(V)\n\nUnpacks the velocity arrays V from the StokesArrays A.\n\n\n\n\n\n","category":"macro"},{"location":"man/listfunctions/#JustRelax.DataIO.checkpointing-NTuple{5, Any}","page":"List of functions","title":"JustRelax.DataIO.checkpointing","text":"checkpointing(dst, stokes, T, η, time)\n\nSave necessary data in dst as and HDF5 file to restart the model from the state at time\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.metadata-Tuple{Any, Any, Any}","page":"List of functions","title":"JustRelax.DataIO.metadata","text":"metadata(src, file, dst)\n\nCopy file, Manifest.toml, and, Project.toml from src to dst\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.save_hdf5-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N","page":"List of functions","title":"JustRelax.DataIO.save_hdf5","text":"function save_hdf5(dst, fname, data)\n\nSave data as the fname.h5 HDF5 file in the folder dst\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#JustRelax.DataIO.save_hdf5-Union{Tuple{N}, Tuple{Any, Vararg{Any, N}}} where N","page":"List of functions","title":"JustRelax.DataIO.save_hdf5","text":"function save_hdf5(fname, data)\n\nSave data as the fname.h5 HDF5 file\n\n\n\n\n\n","category":"method"},{"location":"man/backend/#Selecting-the-backend","page":"Backend","title":"Selecting the backend","text":"","category":"section"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"JustRelax supports three backends: CPU, and CUDA and AMD GPU cards. To use the default CPU backend, simply load JustRelax:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"The GPU backends are implemented as extensions, so it is enough to load the appropriate GPU Pkg before loading JustRelax. That is, to use CUDA cards:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using CUDA, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and for AMD cards:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using AMDGPU, JustRelax","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"Two and three dimensional solvers are implemented in different submodules, which also need to be loaded. To use the two-dimensional backend:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax2D","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"and for the three-dimensional backend:","category":"page"},{"location":"man/backend/","page":"Backend","title":"Backend","text":"using JustRelax.JustRelax3D","category":"page"},{"location":"#JustRelax.jl","page":"Home","title":"JustRelax.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Need to solve a very large multi-physics problem on many GPUs in parallel? Just Relax!","category":"page"},{"location":"","page":"Home","title":"Home","text":"JustRelax is a collection of accelerated iterative pseudo-transient solvers using MPI and multiple CPU or GPU backends. It's part of the PTSolvers organisation and developed within the GPU4GEO project. Current publications, outreach and news can be found on the GPU4GEO website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package relies on other packages as building blocks and parallelisation tools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ParallelStencil.jl - device agnostic parallel kernels\nImplicitGlobalGrid.jl - (CUDA-aware) MPI communication\nGeoParams.jl - Material physics\nJustPIC.jl - Particle-in-cell advection","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package serves several purposes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides a collection of solvers to be used in quickly developing new applications\nIt provides some standardization so that application codes can\nmore easily handle local material properties through the use of GeoParams.jl\nmore easily switch between a pseudo-transient solver and another solvers (e.g. an explicit thermal solvers)\nIt provides a natural repository for contributions of new solvers for use by the larger community","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide several miniapps, each designed to solve a well-specified benchmark problem, in order to provide","category":"page"},{"location":"","page":"Home","title":"Home","text":"examples of usage in high-performance computing\nbasis on which to build more full-featured application codes\ncases for reference and performance tests","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"JustRelax is a registered package and can be added as follows:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.add(\"JustRelax\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> ]\n(@v1.10) pkg> add JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"However, as the API is changing and not every feature leads to a new release, one can also do add JustRelax#main which will clone the main branch of the repository. After installation, you can test the package by running the following commands:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using JustRelax\njulia> ]\n  pkg> test JustRelax","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The test will take a while, so grab a :coffee: or :tea:","category":"page"},{"location":"man/equations/#Pseudo-transient-iterative-method","page":"Equations","title":"Pseudo-transient iterative method","text":"","category":"section"},{"location":"man/equations/#Heat-diffusion","page":"Equations","title":"Heat diffusion","text":"","category":"section"},{"location":"man/equations/#Stokes-equations","page":"Equations","title":"Stokes equations","text":"","category":"section"},{"location":"man/equations/#Constitutive-equations","page":"Equations","title":"Constitutive equations","text":"","category":"section"}]
}
